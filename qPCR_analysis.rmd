---
title: "Waterlogging qPCR Analysis"
output: html_document
---

```{r setup, include = FALSE}

```

```{r libraries, include = FALSE}
library(data.table)
library(ggpubr)
```

```{r variables}
data_columns <- c(
    "Well", "Target", "Content", "Replicate", "Sample", "Dilution",
    "Cq", "Cq Mean", "Cq Std. Dev", "Starting Quantity (SQ)"
)

```

## Load qPCR Data

```{r data}

#' Load qPCR data from a csv file
#' @param file_path The path to the csv file
#' @param header_rows The number of header rows to skip
#' @param columns The columns to select
#' @return A list containing the samples, standards, and NTCs
#'
load_qpcr_data <- function(file_path, header_rows = 0, columns = data_columns) {
    data <- fread(file_path, skip = header_rows, select = columns)
    setnames(
        data,
        c("Cq Mean", "Cq Std. Dev", "Starting Quantity (SQ)"),
        c("Cq_mean", "Cq_sd", "Concentration")
    )
    plate <- list(
        samples   = data[grepl("Unkn", Content)],
        standards = data[grepl("Std", Content)],
        ntcs      = data[grepl("NTC", Content)]
    )
    plate$samples$Sample <- as.integer(plate$samples$Sample)
    plate$samples$Concentration <- 1 / plate$samples$Dilution
    return(plate)
}

plate_1 <- load_qpcr_data("Data/2025-02-26 plate 1 roots ITS.csv", 19)
plate_1$samples
```

## Remove triplicate outliers

Probably the best method for determining outliers is to calculate $\Delta C_q$ between each triplicate and the median and then remove outliers over a threshold.

Samples above a maximum $C_q$ value are also removed.

If only a single replicate from a triplicate remains, the sample is removed and the corresponding sample from the other dilution is also removed because efficiency cannot be calculated.

Removed outliers are listed in a dataframe.

```{r remove_outliers}

#' Remove outliers from a qPCR plate with Cq standard deviation > threshold
#' or the Cq value is above a maximum value
#' @param data A data.table containing qPCR data
#' @param threshold The standard deviation threshold
#' @param max_cq The maximum Cq value to keep
#' @return A list containing the cleaned data and a data.table of outliers
#'
remove_outliers <- function(data, threshold = 0.5, max_cq = 35) {
    outliers <- data[,
        list(
            Well = Well,
            Sample = Sample,
            Target = Target,
            Dilution = Dilution,
            Cq = Cq,
            Outlier = ifelse(
                abs(Cq - median(Cq)) > threshold | Cq > max_cq | is.na(Cq),
                TRUE,
                FALSE
            )
        ),
        by = Replicate
    ][order(Sample)]

    # Remove singletons
    outliers[,
        Singleton := ifelse(sum(Outlier) > 1, TRUE, FALSE),
        by = Replicate
    ]

    # Remove corresponding samples from other dilutions
    outliers[,
        Corresponding := ifelse(sum(Outlier, Singleton) > 3, TRUE, FALSE),
        by = Sample
    ]

    # Remove outliers from data
    outliers <- outliers[Outlier == TRUE | Singleton == TRUE | Corresponding == TRUE]
    data <- data[!Well %in% outliers$Well]

    return(list(samples = data, outliers = outliers))
}

outliers <- remove_outliers(plate_1$samples)
plate_1$samples <- outliers$samples
plate_1$outliers <- outliers$outliers
plate_1$outliers
```

## Standard curve

```{r standard_curve}

#' Calculate the standard curve for a qPCR plate
#' @param data A data.table containing qPCR standard curve data
#' @return A list containing the intercept, slope, R^2, and efficiency
#'
calculate_standard_curve <- function(data) {
    model <- lm(Cq ~ log10(Concentration), data)
    intercept <- model$coefficients[1]
    slope <- model$coefficients[2]
    r_squared <- summary(model)$r.squared
    efficiency <- 10^(-1 / slope)
    return(list(intercept = intercept, slope = slope, r_squared = r_squared, efficiency = efficiency))
}

# Remove outliers from the standards
outliers <- remove_outliers(plate_1$standards)
plate_1$standards <- outliers$samples

# Calculate the standard curve
plate_1$standard_curve <- calculate_standard_curve(plate_1$standards)
plate_1$standard_curve

# Plot standard curve
plate_1$standards[, log10_concentration := log10(Concentration)]
ggscatter(
    plate_1$standards, x = "log10_concentration", y = "Cq",
    add = "reg.line", conf.int = TRUE
) +
    stat_regline_equation(
        aes(label = paste(after_stat(eq.label), after_stat(rr.label), sep = "~~~~")),
        label.x = -2, label.y = 30)

```

## Summary statistics

```{r summary_statistics}

#' Calculate the efficiency of a qPCR reaction based on the equation
#' \deqn{E = 10^{-1/slope}}
#' @param slope The slope between the Cq and log10 concentration 
#' @return The efficiency of the qPCR reaction
#'
efficiency <- function(slope) {
    efficiency <- 10^(-1 / slope)
    return(efficiency)
}

#' Calculate summary statistics for each sample in a qPCR plate
#' @param data A data.table containing qPCR data
#' @return A data.table containing the summary statistics
#'
calculate_summary_statistics <- function(data) {
    summary_statistics <- data[,
        {
            model <- lm(Cq ~ log10(Concentration))
            intercept <- model$coefficients[1]
            slope <- model$coefficients[2]
            list(
                Target = Target[1],
                Intercept = intercept,
                Slope = slope,
                R2 = summary(model)$r.squared,
                Efficiency = efficiency(slope)
            )
        },
        by = Sample
    ][order(Sample)]
    return(summary_statistics)
}

# Calculate summary statistics for each sample in plate 1 sorted by sample
plate_1$stats <- calculate_summary_statistics(plate_1$samples)
plate_1$stats

# Add efficiency to the plate 1 samples
plate_1$samples <- merge(plate_1$samples, plate_1$stats, by = c("Sample", "Target"))
```