---
title: "Waterlogging microbiome analysis"
author: "Hamish McLean"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: TRUE
    toc_float: TRUE
    number_sections: TRUE
    theme: cerulean
    highlight: tango
params:
  alpha_cache: TRUE
  pipeline: "DADA2"
---

## Setup

```{r setup, include=FALSE}

if (!exists("params")) params <- list(pipeline = "DADA2")

knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, error = TRUE)

# Kable options
# options(
#   browser = "false",
#   kableExtra.html.bsTable = TRUE,
#   kableExtra.bootstrap_options = c("striped", "hover", "condensed"),
#   kableExtra_view_html = interactive(),
#   knitr.table.format = "html",
#   viewer = NULL # Disable viewer to avoid opening in browser
# )

# Sys.setenv("BROWSER" = "false")

```

```{r libraries}

library(buildmer)
library(car)
library(cowplot)
library(data.table)
library(DESeq2)
library(dplyr)
library(DT)
library(emmeans)
library(ggpubr)
library(gplots)
library(gridExtra)
library(here)
library(kableExtra)
library(lmerTest)
library(lme4)
library(lmPerm)
library(partR2)
library(patchwork)
library(performance)
library(permutes)
library(rstatix)
library(see)
library(stringr)
library(tidyr)
library(vegan)
library(viridis)

```

```{r functions}

here <- here::here()

FUNC_DIR <- here("functions")

source(here(FUNC_DIR, "functions.R"))
source(here(FUNC_DIR, "loadme.R"))
source(here(FUNC_DIR, "metabarcoding.R"))
source(here(FUNC_DIR, "metafuncs.R"))
source(here(FUNC_DIR, "rarefaction.R"))

# knit_print.datatable <- function(x, ...) {
#   htmltools::browsable(x)
# }

```

```{r constants}

DATA_DIR    <- normalizePath(here("..", "Data"))
FIGURES_DIR <- here("figures")
OBJECT_DIR  <- here("objects")

# Bioinformatics pipeline (defaults to DADA2)
# This should be set in the YAML header or passed as a parameter
PIPELINE    <- params$pipeline # DADA2 or USEARCH
ASV_FILTER  <- 0.001 # ASV filter for removing low abundance ASVs
READ_FILTER <- 0.05  # Read count filter for rarefaction
TAX_CONF    <- 0.65  # Confidence threshold for taxonomic rank assignment
SEED        <- 25647 # Random seed

alpha_cache <- params$alpha_cache

# Colour blind palette
cbPalette   <- c(
  "#000000", "#E69F00", "#56B4E9", "#009E73", 
  "#F0E442", "#0072B2", "#D55E00", "#CC79A7"
)

# Model designs
# Timepoint model for E1
T_DESIGN   <- ~ block + timepoint * treatment + Error(plot)
T_DESIGN_M <- ~ timepoint * treatment + (1 | plot)

# Experiment model without timepoint 2
E_DESIGN   <- ~ experiment:block + experiment * treatment
E_DESIGN_M <- ~ experiment * treatment + (1 | experiment:block)

```

## Load data

Load data from R objects.

```{r load data}

FUN  <- readRDS(here(OBJECT_DIR, "FUN.rds"))
BAC  <- readRDS(here(OBJECT_DIR, "BAC.rds"))

EXP  <- readRDS(here(OBJECT_DIR, "EXP.rds"))
TIME <- readRDS(here(OBJECT_DIR, "TIME.rds"))

```

## Community size

### Copy number plots

```{r copy number plots}

copyNumberPlot <- function(data, x) {
  ggboxplot(
    data,
    x = x,
    y = "log10_copy_number",
    color = "weeks", 
    # fill = "weeks",
    add = c("jitter"),
    # jitter.color = "weeks",
    # jitter.alpha = 0.1,
    # jitter.width = 0.1,
    facet.by = c("type", "source"),
    scales = "free",
    legend = "bottom"
    # palette = "jco"
  ) + labs(
    x = x,
    y = bquote(log[10] ~ "copy number")
  )
}

copy_number_combined <- rbind(
  FUN$colData %>% mutate(type = "Fungi"),
  BAC$colData %>% mutate(type = "Bacteria")
)

# Experiment
copyNumberPlot(filter(copy_number_combined, timepoint == 1), "experiment")
ggsave(filename = "CN_EXP.png", path = FIGURES_DIR)

# Timepoint
copyNumberPlot(filter(copy_number_combined, experiment == 1), "timepoint")
ggsave(filename = "CN_TIME.png", path = FIGURES_DIR)

```

### Copy number models

#### Linear mixed effects models

```{r copy number mixed models, eval = FALSE}

exp_cn  <- apply_to_subsets(EXP, copyNumberModelLMM, E_DESIGN_M) |> combineTables()
time_cn <- apply_to_subsets(TIME, copyNumberModelLMM, T_DESIGN_M) |> combineTables()

# exp_cn  [P <= 0.05 & factor != "(Intercept)"] |> printTable("Experiment")
# time_cn [P <= 0.05 & factor != "(Intercept)"] |> printTable("Timepoint")

# Full tables
exp_cn  |> printTable("Experiment")
time_cn |> printTable("Timepoint")


# lmer(update(E_DESIGN_M, copy_number ~ .), EXP$FUN$soil$colData) |> residuals() |> qqnorm()

```

#### Linear models

```{r copy number models}

# apply_to_subsets(EXP, copyNumberModelLM, E_DESIGN) |> combineTables()

# apply_to_subsets(TIME, copyNumberModelLM, T_DESIGN) |> combineTables()


# a <- aov(update(T_DESIGN, copy_number ~ .), TIME$FUN$soil$colData)
# ggqqplot(residuals(a))
# ggsave(filename = "test_plot.png", path = FIGURES_DIR)

# summary(a)

genericAnova <- function(data, kingdom, source, design) {
  anova    <- aov(design, data$colData)
  anova_df <- summary(anova)[[1]]
  total_ss <- sum(anova_df[["Sum Sq"]])
  data.table(
    kingdom = kingdom,
    source  = source,
    factor  = rownames(anova_df) |> trimws(),
    df      = anova_df[["Df"]],
    SS      = anova_df[["Sum Sq"]],
    MS      = anova_df[["Mean Sq"]],
    F       = anova_df[["F value"]],
    P       = anova_df[["Pr(>F)"]],
    stars   = p_stars(anova_df[["Pr(>F)"]]),
    ges     = anova_df[["Sum Sq"]] / total_ss
  )
}

exp_cn_lm <- apply_to_subsets(EXP, genericAnova, update(E_DESIGN, log10(copy_number) ~ .)) |> combineTables()

exp_cn_lm |> printTable("Experiment")

# apply_to_subsets(TIME, genericAnova, update(T_DESIGN, log10_copy_number ~ .)) |> combineTables()


timepointAnova <- function(data, kingdom, source, design) {
  anova     <- aov(update(design, log10(copy_number)  ~ .), data$colData)
  plot_df   <- summary(anova)[["Error: plot"]][[1]]
  # plot_ss   <- sum(plot_df[["Sum Sq"]])
  # plot_df$var <- plot_df[["Sum Sq"]] / plot_ss * 100
  within_df <- summary(anova)[["Error: Within"]][[1]]
  # within_ss <- sum(within_df[["Sum Sq"]])
  # within_df$var <- within_df[["Sum Sq"]] / within_ss * 100
  anova_df  <- bind_rows(plot_df, within_df)

  grand_mean <- mean(data$colData$log10_copy_number, na.rm = TRUE)
  total_ss   <- sum((data$colData$log10_copy_number - grand_mean)^2, na.rm = TRUE)
  data.table(
    kingdom = kingdom,
    source  = source,
    factor  = rownames(anova_df) |> trimws(),
    df      = anova_df[["Df"]],
    SS      = anova_df[["Sum Sq"]],
    MS      = anova_df[["Mean Sq"]],
    F       = anova_df[["F value"]],
    P       = anova_df[["Pr(>F)"]],
    stars   = p_stars(anova_df[["Pr(>F)"]]),
    ges     = anova_df[["Sum Sq"]] / total_ss
  )
}

# timepointAnova(TIME$FUN$soil, "Fungi", "soil", T_DESIGN)

time_cn_lm <- apply_to_subsets(TIME, timepointAnova, T_DESIGN) |> combineTables()

time_cn_lm |> printTable("Timepoint")

# t <- log10_copy_number ~ block + timepoint * treatment + Error(plot)

# lm(t, TIME$FUN$soil$colData)

# anova_test(
#   TIME$FUN$soil$colData, 
#   formula = log10_copy_number ~ block + timepoint * treatment,# + Error(plot),
#   # dv = log10_copy_number, 
#   # wid = plot,
#   # # between = c(block, treatment),
#   # within = timepoint,
#   type = 3,
#   effect.size = "res"
# )


# anova_test(
#   TIME$FUN$soil$colData, 
#   log10_copy_number ~ block + timepoint * treatment + Error(plot),
#   type = 3,
#   effect.size = "res"
# )


# emmeans
emmMain <- function(model, k, s, specs, section = NULL) {
  # dat <- data[[k]][[s]]$colData
  # model <- aov(update(design, log10(copy_number) ~ .), data$colData)
  emm <- emmeans(model, specs, type = "response") |> suppressMessages()
  # return(emm)
  res <- if(is.null(section)) emm else emm[[section]] |> as.data.frame()
  mutate(res, kingdom = k, source = s)
}

e_anova <- apply_to_subsets(
  EXP, function(data, k, s, design) aov(design, data$colData), 
  update(E_DESIGN, log10(copy_number) ~ .)
)

# t_anova <- apply_to_subsets(
#   TIME, function(data, k, s, design) aov(design, data$colData), 
#   update(T_DESIGN, log10(copy_number) ~ .)
# )

# emmMain(e_anova$FUN$root, "FUN", "root", pairwise ~ experiment, "contrasts", EXP)
# emmMain(t, "k", "s", pairwise ~ timepoint, "contrasts")
# emmMain(t_anova$FUN$root, "k", "s", pairwise ~ timepoint, "contrasts", TIME)
# emmMain(t_anova$FUN$root, "FUN", "root", ~ timepoint, data = TIME)


# Experiment
# All experiment contrasts
apply_to_subsets(e_anova, emmMain, pairwise ~ experiment, "emmeans") |> 
  combineTables() |> printTable("Experiment")
apply_to_subsets(e_anova, emmMain, pairwise ~ experiment, "contrasts") |> 
  combineTables() |> printTable("Experiment")

# Timepoint
# All timepoint contasts
# apply_to_subsets(TIME, emmMain, T_DESIGN, pairwise ~ timepoint, "emmeans") |> combineTables()
# apply_to_subsets(t_anova, emmMain, pairwise ~ timepoint, "contrasts", TIME) |> combineTables()

# apply_to_subsets(t_anova, emmMain, ~ timepoint, data = TIME) |> combineTables()

# emmMain <- function(data, k, s, design, specs, section = NULL) {
#   model <- aov(design, data$colData)
#   emm <- emmeans(model, specs, type = "response") |> suppressMessages()
#   return(emm)
#   # return(emm)
#   res <- if(is.null(section)) emm else emm[[section]] |> as.data.frame()
#   mutate(res, kingdom = k, source = s)
# }


t_design <- update(T_DESIGN, log10(copy_number) ~ .)

# emmMain(TIME$FUN$soil, "FUN", "soil", t_design, pairwise ~ timepoint)

emmeans(aov(t_design, TIME$FUN$soil$colData), pairwise ~ timepoint, type = "response")
emmeans(aov(t_design, TIME$BAC$root$colData), pairwise ~ timepoint, type = "response")
emmeans(aov(t_design, TIME$FUN$soil$colData), pairwise ~ timepoint, type = "response")
emmeans(aov(t_design, TIME$BAC$root$colData), pairwise ~ timepoint, type = "response")




# e <- aov(update(E_DESIGN, log10(copy_number) ~ .), EXP$FUN$soil$colData)

# emmeans(e, ~ experiment, type = "response")
# emmeans(e, pairwise ~ experiment, type = "response")
# emmeans(e, pairwise ~ treatment|experiment, type = "response")
# emmeans(e, trt.vs.ctrl ~ treatment|experiment, type = "response")
# emmeans(e, specs = "experiment", by = "treatment", type = "response")


# t <- aov(update(T_DESIGN, log10(copy_number) ~ .), TIME$FUN$soil$colData)

# emmeans(t, ~ timepoint, type = "response")
# emmeans(t, pairwise ~ timepoint, type = "response")
# emmeans(t, pairwise ~ treatment|timepoint, type = "response")
# emmeans(t, trt.vs.ctrl ~ treatment|timepoint, type = "response")


```

## Alpha diversity

### Calculate alpha diversity

Add alpha diversity idices to data objects.

```{r calculate alpha diversity}

EXP  <- apply_to_subsets(EXP, calculateAlpha)
TIME <- apply_to_subsets(TIME, calculateAlpha)

```

### Permutation anova of alpha diversity index ranks

`perm.lmer` runs a permutation test for mixed-effects models.
This model takes a long time to run, so results are cached.

```{r alpha diversity analysis, eval = FALSE}

# These models are very slow, only run to update the cached results
if (!alpha_cache) {
  # Define metrics
  metrics <- c("S.chao1", "shannon", "simpson")

  exp_alpha  <- apply_to_subsets(EXP, alphaModel, metrics, E_DESIGN_M) |> combineTables()
  time_alpha <- apply_to_subsets(TIME, alphaModel, metrics, T_DESIGN_M) |> combineTables()

  saveRDS(exp_alpha,  here(OBJECT_DIR, "exp_alpha.rds"))
  saveRDS(time_alpha, here(OBJECT_DIR, "time_alpha.rds"))
} else {
  exp_alpha  <- readRDS(here(OBJECT_DIR, "exp_alpha.rds"))
  time_alpha <- readRDS(here(OBJECT_DIR, "time_alpha.rds"))
}

# exp_alpha [p <= 0.05 & factor != "(Intercept)"] |> printTable()
# time_alpha[p <= 0.05 & factor != "(Intercept)"] |> printTable()

# Full tables
exp_alpha  |> printTable()
time_alpha |> printTable()

```

#### Alpha post-hoc (LMM)

```{r alpha post-hoc LMM, eval = FALSE}

# EXP FUN root Simpson: NS, mean(simpson) slightly higher in treated for both
alphaPostHoc(EXP$FUN$root$alphaData, "simpson", formula(~ treatment + (1 | block)), "experiment")

# EXP FUN soil Chao1: NS, mean(Chao1) slighly higher in E1 trt, lower in E2 trt 
alphaPostHoc(EXP$FUN$soil$alphaData, "S.chao1", formula(~ treatment + (1 | block)), "experiment")

# EXP BAC soil Simpson: NS, mean(Simpson) slightly lower in treated for both
alphaPostHoc(EXP$BAC$soil$alphaData, "simpson", formula(~ treatment + (1 | block)), "experiment")



# TIME FUN soil Simpson: T1 ns, T2 *, higher in treated
alphaPostHoc(TIME$FUN$soil$alphaData, "simpson", formula(~ treatment + (1 | block)), "timepoint")

# TIME FUN soil Shannon: both ns, both lower in treated
alphaPostHoc(TIME$FUN$soil$alphaData, "shannon", formula(~ treatment + (1 | block)), "timepoint")

# TIME BAC root Chao1: both ns, 
alphaPostHoc(TIME$BAC$root$alphaData, "S.chao1", formula(~ treatment + (1 | block)), "timepoint")

# TIME BAC soil Simpson: T1 ns, T2 *, lower in treated
alphaPostHoc(TIME$BAC$soil$alphaData, "simpson", formula(~ treatment + (1 | block)), "timepoint")

```

### Alpha diversity linear models

```{r alpha LM}

metrics <- c("S.chao1", "shannon", "simpson")

# alphaLM(EXP$FUN$soil, "FUN", "soil", metrics, E_DESIGN)

exp_alpha <- apply_to_subsets(EXP, alphaLM, metrics, E_DESIGN)

exp_alpha |> combineTables() |> printTable("Experiment")

# alphaLM(TIME$FUN$soil, "FUN", "soil", metrics, T_DESIGN)

singleAlphaLM <- function(data, kingdom, source, metric, design) {
  formula <- update(design, as.formula(paste0("rank(", metric, ") ~ .")))
  anova <- aovp(formula, data, seqs = TRUE)
  anova_df <- bind_rows(
    summary(anova)[["Error: plot"]][[1]] |> as.data.frame(), 
    summary(anova)[["Error: Within"]][[1]] |> as.data.frame()
  )
  metric_rank <- rank(data[[metric]])
  anova_df$met <- metric
  anova_df$factor <- rownames(anova_df) |> trimws()
  anova_df$total_ss <- sum((metric_rank - mean(metric_rank))^2)
  data.table(
    kingdom = kingdom,
    source  = source,
    metric  = anova_df$met,
    factor  = anova_df$factor,
    df      = anova_df[["Df"]],
    SS      = anova_df[["R Sum Sq"]],
    MS      = anova_df[["R Mean Sq"]],
    Iter    = anova_df[["Iter"]],
    p       = anova_df[["Pr(Exact)"]],
    stars   = p_stars(anova_df[["Pr(Exact)"]]),
    var     = anova_df[["R Sum Sq"]] / anova_df$total_ss * 100
  )
}

# singleAlphaLM(TIME$FUN$soil$alphaData, "FUN", "soil", "S.chao1", T_DESIGN)

time_alpha <- list(
  FUN = list(
    root = bind_rows(
      singleAlphaLM(TIME$FUN$root$alphaData, "FUN", "root", "S.chao1", T_DESIGN),
      singleAlphaLM(TIME$FUN$root$alphaData, "FUN", "root", "shannon", T_DESIGN),
      singleAlphaLM(TIME$FUN$root$alphaData, "FUN", "root", "simpson", T_DESIGN)
    ),
    soil = bind_rows(
      singleAlphaLM(TIME$FUN$root$alphaData, "FUN", "soil", "S.chao1", T_DESIGN),
      singleAlphaLM(TIME$FUN$root$alphaData, "FUN", "soil", "shannon", T_DESIGN),
      singleAlphaLM(TIME$FUN$root$alphaData, "FUN", "soil", "simpson", T_DESIGN)
    )
  ),
  BAC = list(
    root = bind_rows(
      singleAlphaLM(TIME$BAC$root$alphaData, "BAC", "root", "S.chao1", T_DESIGN),
      singleAlphaLM(TIME$BAC$root$alphaData, "BAC", "root", "shannon", T_DESIGN),
      singleAlphaLM(TIME$BAC$root$alphaData, "BAC", "root", "simpson", T_DESIGN)
    ),
    soil = bind_rows(
      singleAlphaLM(TIME$BAC$root$alphaData, "BAC", "soil", "S.chao1", T_DESIGN),
      singleAlphaLM(TIME$BAC$root$alphaData, "BAC", "soil", "shannon", T_DESIGN),
      singleAlphaLM(TIME$BAC$root$alphaData, "BAC", "soil", "simpson", T_DESIGN)
    )
  )
)

time_alpha |> combineTables() |> printTable("Timepoint")


# Summary tables

summariseAlpha <- function(data) {
  combined_data <- combineTables(data)
  combined_data$factor <- factor(combined_data$factor, levels = unique(combined_data$factor))
  dt <- dcast(
    combined_data,
    kingdom + factor + df ~ source + metric,
    value.var = c("var", "stars")
  )
  id_cols <- c("kingdom", "factor", "df")
  all_cols <- setdiff(names(dt), id_cols)
  base_cols <- unique(sub("^(var|stars)_", "", all_cols))
  final_cols <- c(
    id_cols,
    as.vector(sapply(base_cols, function(x) c(paste0("var_", x), paste0("stars_", x))))
  )
  setcolorder(dt, final_cols)
  dt
}

summariseAlpha(exp_alpha)  |> printTable("Experiment")
summariseAlpha(time_alpha) |> printTable("Timepoint")

# combineTables(exp_alpha)$factor |> as.ordered()


# Post hoc analysis

# Bacteria soil Simpson
# dat <- EXP$BAC$soil$alphaData
# dat$simpson_rank <- rank(dat$simpson)
# ## E1
# dat[experiment == 1]$simpson_rank |> mean()
# ##E2
# dat[experiment == 2]$simpson_rank |> mean()

# emmeans(
#   aovp(update(E_DESIGN, rank(simpson) ~ .), dat, seqs = TRUE)
# )

# pairwise.wilcox.test(
#   x = dat$simpson_rank, # Your response variable
#   g = dat$experiment,       # Your grouping factor
#   p.adjust.method = "bonferroni"
# )

# anovaResults <- function(data, k, s, design) {
#   anova <- aovp(update(design, measure ~ .))
#   anova_df <- if (length(anova) > 3) { # length = 3 for repeat measures anova
#     summary(anova)[[1]] # anova |> data.frame()
#   } else {
#     bind_rows(
#       summary(anova)[["Error: plot"]][[1]], 
#       summary(anova)[["Error: Within"]][[1]]
#     )
#   }
#   # total_ss <- sum(anova_df["Sum Sq"])
#   total_ss <- sum((pc_dat - mean(pc_dat))^2)
#   data.table(
#     kingdom = kingdom,
#     source  = source,
#     pc      = pc_name,
#     factor  = rownames(anova_df) |> trimws(),
#     df      = anova_df[["Df"]],
#     SS      = anova_df[["Sum Sq"]],
#     MS      = anova_df[["Mean Sq"]],
#     F       = anova_df[["F value"]],
#     P       = anova_df[["Pr(>F)"]],
#     var     = anova_df[["Sum Sq"]] / total_ss * 100
#   )
# }

```

#### Alpha diversity post-hoc (linear models)

```{r alpha post-hoc (LM)}

# Compare means between experiments

alphaPostHoc <- function(data, kingdom, source, metrics, factor, lvl) {
  dt  <- data$alphaData
  for (met in metrics) dt[, (paste0(met, "_rank")) := rank(get(met))]
  ranks <- sapply(metrics, function(met) paste0(met, "_rank"))
  res <- data.table(
    Kingdom = kingdom,
    Source  = source,
    Metric  = metrics
  )
  res[, (paste(factor, lvl[1])) := sapply(ranks, function(m) mean(dt[get(factor) == lvl[1]][[m]]))]
  res[, (paste(factor, lvl[2])) := sapply(ranks, function(m) mean(dt[get(factor) == lvl[2]][[m]]))]
  res[, diff := get(paste(factor, lvl[2])) - get(paste(factor, lvl[1]))]
}

# Experiment
apply_to_subsets(EXP, alphaPostHoc, metrics, "experiment", c(1, 2)) |> combineTables() |> printTable("Experiment")
apply_to_subsets(EXP, alphaPostHoc, metrics, "treatment", c(0, 1)) |> combineTables() |> printTable("Experiment: treatment")

# Timepoint
apply_to_subsets(TIME, alphaPostHoc, metrics, "timepoint", c(1, 2)) |> combineTables() |> printTable("Timepoint")
apply_to_subsets(TIME, alphaPostHoc, metrics, "treatment", c(0, 1)) |> combineTables() |> printTable("Timepoint: treatment")


# Interactions

alphaEach <- function(data, kingdom, source, metrics, design, type) {
  cat(paste0("\nAnalyzing alpha diversity for ", kingdom, ": ", source, "\n"))

  # Subset data
  data_subsets <- split(data$alphaData, as.formula(paste("~", type)))

  # Run alpha diversity analysis for each metric
  anova_results <- list()

  for (met in metrics) {
    formula <- update(design, as.formula(paste0("rank(", met, ") ~ .")))

    # anova <- lapply(data_subsets, function(d) aovp(formula, data = d, seqs = TRUE))
    df_list <- lapply(data_subsets, function(d) {
      anova <- aovp(formula, data = d, seqs = TRUE)
      df <- summary(anova)[[1]] |> as.data.frame()
      setDT(df, keep.rownames = "factor")
      df[, total_ss := sum((rank(d[[met]]) - mean(rank(d[[met]])))^2)]
    })

    anova_df <- rbindlist(df_list, idcol = type)
    anova_df$metric <- met
    
    anova_results[[met]] <- anova_df
  }

  results <- rbindlist(anova_results)

  results[, var := get("R Sum Sq") / total_ss * 100]
  # return(results)
  data.table(
    kingdom = kingdom,
    source  = source,
    type    = results[[type]],
    metric  = results$metric,
    factor  = results$factor,
    df      = results[["Df"]],
    SS      = results[["R Sum Sq"]],
    MS      = results[["R Mean Sq"]],
    p       = results[["Pr(Exact)"]],
    stars   = p_stars(results[["Pr(Exact)"]]),
    var     = results[["R Sum Sq"]] / results$total_ss * 100
  ) %>% setnames(old = "type", new = type)
}

design <- ~ block + treatment

# alphaEach(EXP$FUN$soil, "kingdom", "source", metrics, design, "experiment") |> print()

exp_alpha_each  <- apply_to_subsets(EXP, alphaEach, metrics, design, "experiment")
time_alpha_each <- apply_to_subsets(TIME, alphaEach, metrics, design, "timepoint")

exp_alpha_each  |> combineTables() |> printTable("Experiment")
time_alpha_each |> combineTables() |> printTable("Timepoint")

combineTables(exp_alpha_each)[p < 0.05]
combineTables(time_alpha_each)[p < 0.05]

## EXP FUN root simpson & soil Chao1
## EXP BAC root all & soil Chao1 Simpson
## TIME BAC root Chao1 soil Chao1

summariseAlphaEach <- function(data) {
  combined_data <- combineTables(data)
  combined_data$factor <- factor(combined_data$factor, levels = unique(combined_data$factor))
  dt <- dcast(
    combined_data,
    kingdom + factor + df ~ source + metric + experiment,
    value.var = c("var", "stars")
  )
  id_cols <- c("kingdom", "factor", "df")
  all_cols <- setdiff(names(dt), id_cols)
  base_cols <- unique(sub("^(var|stars)_", "", all_cols))
  final_cols <- c(
    id_cols,
    as.vector(sapply(base_cols, function(x) c(paste0("var_", x), paste0("stars_", x))))
  )
  setcolorder(dt, final_cols)
  dt
}

summariseAlphaEach(exp_alpha_each)  |> printTable("Experiment")
summariseAlphaEach(time_alpha_each) |> printTable("Timepoint")


alphaPostHocEach <- function(data, kingdom, source, metrics, type) {
  # Split data
  split_data <- split(data$alphaData, as.formula(paste("~", type)))
  # Calculate ranks for each data split 
  for (m in metrics) sapply(split_data, function(dt) dt[, (m) := rank(get(m))])
  group_cols <- c("source", "experiment", "timepoint", "treatment")
  # Summarise by treatment and reformat
  rank_means <- lapply(split_data, function(dt) {
    dt[, lapply(.SD, mean), by = group_cols, .SDcols = metrics] %>%
      melt(id.vars = group_cols, measure_vars = metrics, variable.name = "metric") %>%
      dcast(source + experiment + timepoint + metric ~ treatment, value.var = "value")
  }) |> rbindlist()

  data.table(
    Kingdom    = kingdom,
    Source     = rank_means$source,
    Experiment = rank_means$experiment,
    Timepoint  = rank_means$timepoint,
    Metric     = rank_means$metric,
    Trt_0      = rank_means$'0',
    Trt_1      = rank_means$'1',
    diff       = rank_means$'1' - rank_means$'0'
  )
}

# alphaPostHocEach(EXP$FUN$soil, "FUN", "soil", metrics, "experiment") |> print()

apply_to_subsets(EXP, alphaPostHocEach, metrics, "experiment") |> combineTables() |> printTable()
apply_to_subsets(TIME, alphaPostHocEach, metrics, "timepoint") |> combineTables() |> printTable()

```

### Alpha diversity plots

```{r alpha diversity plots}

measures <- c("Chao1", "Shannon", "Simpson")

plotAlpha <- function(data, k, s, measures, design) {
  plot_alpha(
    data$countData, data$colData,
    design = design, colour = "weeks",
    measures = measures,
    type = "box"
  ) + scale_colour_manual(values = cbPalette) +
    # theme(axis.title.x = element_blank()) +
    ggtitle(paste(k, ":", s))
}

exp_alpha_plots <- apply_to_subsets(EXP, plotAlpha, measures, "experiment") |> unlist(FALSE)

# ggarrange(exp_alpha_plots, ncol = 2, common.legend = TRUE, legend = "bottom")

# plot_grid(
#   plotlist = exp_alpha_plots,
#   align = "h",
#   ncol = 2
# )

(exp_alpha_plots[[1]] + exp_alpha_plots[[2]]) / (exp_alpha_plots[[3]] + exp_alpha_plots[[4]]) +
  plot_layout(guides = "collect") & # Collect legends into a single common legend
  theme(legend.position = "bottom") # Position the common legend

ggsave("alpha_EXP.png", path = FIGURES_DIR)


time_alpha_plots <- apply_to_subsets(TIME, plotAlpha, measures, "timepoint") |> unlist(FALSE)

(time_alpha_plots[[1]] + time_alpha_plots[[2]]) / (time_alpha_plots[[3]] + time_alpha_plots[[4]]) +
  plot_layout(guides = "collect") & # Collect legends into a single common legend
  theme(legend.position = "bottom") # Position the common legend

ggsave("alpha_TIME.png", path = FIGURES_DIR)

```

## Beta diversity: Bray-Curtis

### PERMANOVA of Bray-Curtis dissimilarity

Block included as a main effect in the design formula.

```{r adonis}

# Designs for ADONIS
# e_design <- vg ~ experiment/block * treatment

t_design <- vg ~ block + timepoint * treatment


# Apply adonis analysis to each subset of data
exp_bc  <- apply_to_subsets(EXP, adonisModel, update(E_DESIGN, vg ~ .)) |> combineTables()

time_bc <- apply_to_subsets(TIME, adonisModel, t_design, "plot") |> combineTables()

# exp_bc[P < 0.05]  |> printTable()
# time_bc[P < 0.05] |> printTable()

# Full tables
exp_bc  |> printTable("Experiment")
time_bc |> printTable("Timepoint")

```

#### Post-hoc analysis

```{r adonis post-hoc}

#' @title Post-hoc analysis for adonis2 interaction terms
#' @description Splits data by a grouping variable and runs a simplified
#'   adonis2 model on each subset to investigate a significant interaction.
#' @param data A data.frame or data.table containing the experiment metadata.
#' @param counts A matrix or data.frame of raw or normalized counts (e.g., from DESeq2).
#' @param simplified_formula A formula object for the fixed effects of the simplified model (e.g., `~ treatment`).
#' @param group_by_var A string representing the column name to split the data by (e.g., "experiment" or "timepoint").
#' @param nperm The number of permutations to use for adonis2.
#' @return A list of the adonis2 results (data.tables) for each subset.
#' 
adonisPostHoc <- function(data, kingdom, source, design, type, nperm = 1000) {

  # Split the data into a list of data.tables based on the grouping variable
  split_data <- split(data$colData, as.formula(paste("~", type)))

  # Initialize a list to store the results
  adonis_results <- list()

  # Iterate through each subset of the data
  for (group_name in names(split_data)) {
    subset_data <- split_data[[group_name]]

    # Subset the counts matrix to match the current metadata subset
    subset_counts <- counts(data$dds, normalize = TRUE)[, rownames(subset_data)]

    # Calculate Bray-Curtis distances for the subset
    vg <- vegdist(t(subset_counts), method = "bray")

    message(paste("Running adonis2 for", type, group_name))

    # Run adonis2 on the subset
    model_result <- tryCatch({
      vegan::adonis2(
        update(design, vg ~ .),
        data = subset_data,
        permutations = nperm,
        by = "terms"
      )
    }, error = function(e) {
      warning(paste("Error running adonis2 for", type, group_name, ":", e$message))
      NULL
    })

    # Convert the adonis2 output to a data.frame for easier handling and store it
    if (!is.null(model_result)) {
      df <- as.data.frame(model_result)
      total_ss <- df["Total", "SumOfSqs"]
      # setDT(df, keep.rownames = "factor")
      adonis_results[[group_name]] <- data.table(
        kingdom = kingdom,
        source  = source,
        type    = group_name,
        factor  = rownames(df),
        df      = df$Df,
        SS      = df$SumOfSqs,
        R2      = df$R2,
        F       = df$F,
        P       = df$'Pr(>F)',
        stars   = p_stars(df$'Pr(>F)'),
        var     = df$SumOfSqs / total_ss * 100
      ) %>% setnames(old = "type", new = type)
    }
  }

  rbindlist(adonis_results)
}

design <- ~ block + treatment

adonisPostHoc(EXP$FUN$soil, "FUN", "soil", design, "experiment")#

exp_bc_each  <- apply_to_subsets(EXP, adonisPostHoc, design, "experiment")
time_bc_each <- apply_to_subsets(TIME, adonisPostHoc, design, "timepoint")

combineTables(exp_bc_each)[P < 0.05]
combineTables(time_bc_each)[P < 0.05]

```

### Bray-Curtis NMDS plots

```{r nmds}

set.seed(SEED)

# Experiment

nmds_exp_fun_root <- nmdsPlot(EXP$FUN$root$dds, shape = "experiment", filename = "NMDS_FUN_root_exp.png")
nmds_exp_fun_soil <- nmdsPlot(EXP$FUN$soil$dds, shape = "experiment", filename = "NMDS_FUN_soil_exp.png")
nmds_exp_bac_root <- nmdsPlot(EXP$BAC$root$dds, shape = "experiment", filename = "NMDS_BAC_root_exp.png")
nmds_exp_bac_soil <- nmdsPlot(EXP$BAC$soil$dds, shape = "experiment", filename = "NMDS_BAC_soil_exp.png")

nmds_exp_combined <- ggarrange(
  plotlist = list(nmds_exp_fun_root, nmds_exp_fun_soil, nmds_exp_bac_root, nmds_exp_bac_soil),
  common.legend = TRUE,
  legend = "bottom",
  labels = c("Fungi: roots", "Fungi: soil", "Bacteria: roots", "Bacteria: soil")
)
nmds_exp_combined
ggsave("NMDS_exp.png", plot = nmds_exp_combined, path = FIGURES_DIR)

# Timepoint

nmds_time_fun_root <- nmdsPlot(TIME$FUN$root$dds, shape = "timepoint", filename = "NMDS_FUN_root_time.png")
nmds_time_fun_soil <- nmdsPlot(TIME$FUN$soil$dds, shape = "timepoint", filename = "NMDS_FUN_soil_time.png")
nmds_time_bac_root <- nmdsPlot(TIME$BAC$root$dds, shape = "timepoint", filename = "NMDS_BAC_root_time.png")
nmds_time_bac_soil <- nmdsPlot(TIME$BAC$soil$dds, shape = "timepoint", filename = "NMDS_BAC_soil_time.png")

nmds_time_combined <- ggarrange(
  plotlist = list(nmds_time_fun_root, nmds_time_fun_soil, nmds_time_bac_root, nmds_time_bac_soil),
  common.legend = TRUE,
  legend = "bottom",
  labels = c("Fungi: roots", "Fungi: soil", "Bacteria: roots", "Bacteria: soil")
)
nmds_time_combined
ggsave("NMDS_time.png", plot = nmds_time_combined, path = FIGURES_DIR)

```

## Beta diversity: PCA

### PCA models

```{r pca}

# Calculate PCA
EXP  <- apply_to_subsets(EXP, calculatePCA)
TIME <- apply_to_subsets(TIME, calculatePCA)


# EXP PC percent variance 
lapply(unlist(EXP, FALSE), function(x) {
  unlist(round(x$pca$percentVar * 100, 2))
}) |> as.data.table() |> mutate("PC" = 1:20) |> printTable()

# TIME PC percent variance
lapply(unlist(TIME, FALSE), function(x) {
  unlist(round(x$pca$percentVar * 100, 2))
}) |> as.data.table() |> mutate("PC" = 1:20) |> printTable()


# e_design <- ~ treatment * experiment + experiment:block
# t_design <- ~ treatment * timepoint

# EXP PCA linear model
e_pca_lm <- apply_to_subsets(EXP, pcaLM, E_DESIGN, "experiment")
e_pca_lm |> combineTables() |> filter(P <= 0.05 & factor != "(Intercept)") |> printTable()

# TIME PCA linear model
t_pca_lm <- apply_to_subsets(TIME, pcaLM, T_DESIGN, "timepoint")
t_pca_lm |> combineTables() |> filter(P <= 0.05 & factor != "(Intercept)") |> printTable()


#' Summarise PCA results by adjusted variance %
pcaLMVar <- function(data, k, s) {
  data[, .(var_adj = sum(var_adj)), by = .(kingdom, source, factor, df)]
}

apply_to_subsets(e_pca_lm, pcaLMVar) |> combineTables() |> printTable("Experiment")
apply_to_subsets(t_pca_lm, pcaLMVar) |> combineTables() |> printTable("Timepoint")


# # EXP PCA linear mixed model
# apply_to_subsets(EXP, pcaLMM, E_DESIGN_M) |> combineTables() |> 
#   filter(P <= 0.05 & factor != "(Intercept)") |> printTable()

# # TIME PCA linear mixed model
# apply_to_subsets(TIME, pcaLMM, T_DESIGN_M) |> combineTables() |> 
#   filter(P <= 0.05 & factor != "(Intercept)") |> printTable()

```

PCs of interest:

Experiment

- Fungi root: PC8 (int), PC9 (trt)

- Fungi soil: PC6 (trt, exp, & int)

- Bacteria root: PC7 (trt & int), PC8 (trt)

- Bacteria soil: PC3 (trt), PC4 (trt), PC8 (int), PC11 (trt), PC18 (int)

Timepoint

- Fungi root: PC4 (trt), PC5 (trt), PC10 (trt)

- Fungi soil: PC6 (int), PC7 (trt)

- Bacteria root: PC5 (trt, int), PC7 (trt, int), PC11 (int), PC12 (int)

- Bacteria soil: PC5 (trt, time, int), PC15(time, int)


### PC plots

```{r pc plots}

# EXP FUN root PCs 8 & 9
pcaPlot(EXP$FUN$root, c(8, 9), "experiment", "PCA_EXP_FUN_root_PC8-9.png")

# pcaPlot(EXP$FUN$soil, c(6), "experiment", "PCA_EXP_FUN_soil_PC6.png")

# EXP BAC root PCs 7 & 8
pcaPlot(EXP$BAC$root, c(7, 8), "experiment", "PCA_EXP_BAC_root_PC7-8.png")

# EXP BAC soil PCs 3 & 4
pcaPlot(EXP$BAC$soil, c(3, 4), "experiment", "PCA_EXP_BAC_soil_PC3-4.png")

# EXP BAC soil PCs 8 & 11
pcaPlot(EXP$BAC$soil, c(8, 11), "experiment", "PCA_EXP_BAC_soil_PC8-11.png")


# TIME FUN 

```

Insights

EXP FUN root PCs 8 & 9

EXP BAC root PCs 7 & 8
  PC7 exp 1 lest

### PC loadings

```{r pc loadings}

# PC loadings
pcLoadings <- function(data, pc, top_n = 10) {
  df <- cbind(PC = data$pca$x[, pc], data$colData)
  aggregate(PC ~ treatment, df, mean) |> print()

  loadings <- data$pca$rotation[, pc]
  top_asvs <- names(sort(abs(loadings), decreasing = TRUE))[1:top_n]
  data.table(
    PC = pc,
    ASVs = top_asvs,
    loading = loadings[top_asvs],
    taxa = data$taxData[top_asvs, ]$rank
  )
}

# Fungi root PC8
pcLoadings(EXP$FUN$root, 8, 10) |> printTable()

# Fungi root PC8
pcLoadings(EXP$FUN$root, 9, 10) |> printTable()

# Fungi soil PC6
pcLoadings(EXP$FUN$soil, 6, 10) |> printTable()


# Bacteria root PC7
pcLoadings(EXP$BAC$root, 7, 10) |> printTable()

# Bacteria soil PC4
pcLoadings(EXP$BAC$soil, 4, 10) |> printTable()

# Bacteria soil PC8
pcLoadings(EXP$BAC$soil, 8, 10) |> printTable()

```

Note: Multiply absolute loading by proportion of variance in PC explained by treatment
can then multiply this by proportion of variance of PC to the total community


## Differential abundance

```{r differential abundance}

# Run DESeq model
deseqModel <- function(data, k, s, design) {
  design(data$dds) <- design
  data$dds <- DESeq(data$dds)
  data
}

# Treatment effect with interaction

# e_design <- ~ experiment/block + treatment + experiment:treatment
# t_design <- ~ timepoint + block + treatment + timepoint:treatment

# EXP  <- apply_to_subsets(EXP, deseqModel, e_design)
# TIME <- apply_to_subsets(TIME, deseqModel, t_design)

# resultsNames(EXP$FUN$soil$dds)


# Overall treatment effect

e_design <- ~ experiment/block  + treatment
t_design <- ~ timepoint + block + treatment

EXP  <- apply_to_subsets(EXP,  deseqModel, e_design)
TIME <- apply_to_subsets(TIME, deseqModel, t_design)

# resultsNames(EXP$FUN$soil$dds)


# Differential abundance

exp_da <- apply_to_subsets(EXP, diffAbundanceOverall, "experiment")
time_da <- apply_to_subsets(TIME, diffAbundanceOverall, "timepoint")


# exp_da <- split(
#   apply_to_subsets(EXP, diffAbundanceOverall, "experiment") |> combineTables(),
#   f = ~ kingdom
# )

# time_da <- split(
#   apply_to_subsets(TIME, diffAbundanceOverall, "timepoint") |> combineTables(),
#   f = ~ kingdom
# )

# ASV count
append(bind_rows(exp_da$FUN)$ASV, bind_rows(time_da$FUN)$ASV) |> unique() |> length()
append(bind_rows(exp_da$BAC)$ASV, bind_rows(time_da$BAC)$ASV) |> unique() |> length()

```

### Differential abundance tables {.tabset}

#### EXP: FUN

```{r}
exp_da$FUN |> bind_rows() |> printTable()
```

#### EXP: BAC

```{r}
exp_da$BAC |> bind_rows() |> printTable()
```

#### TIME: FUN

```{r}
time_da$FUN |> bind_rows() |> printTable()
```

#### TIME: BAC

```{r}
time_da$BAC |> bind_rows() |> printTable()
```

### Differential abundance subsets

```{r}

exp_da$FUN  |> select("taxa") |> table() |> as.data.table() |> printTable()
time_da$FUN |> select("taxa") |> table() |> as.data.table() |> printTable()

exp_da$FUN[grepl("Dactylonectria", taxa)] |> printTable()
time_da$FUN[grepl("Pleosporales", taxa)]  |> printTable()


exp_da$BAC  |> select("taxa") |> table() |> as.data.table() |> printTable()
time_da$BAC |> select("taxa") |> table() |> as.data.table() |> printTable()

time_da$BAC[grepl("Oxalobacteraceae", taxa)] |> printTable()

```

The fungal taxa with multiple occurences (but different ASVs) had wildly different
results.
There were fewer bacteria with multiple occurences, but the results were more consistant.

## Functional analysis

### FUNGuilds

```{r FUNGuilds}

# Load FUNGuilds data
funguilds <- readRDS(here(OBJECT_DIR, "FUNGuilds.rds"))

mergeFunguilds <- function(data, guilds) {
  merge(data,  guilds, by.x = "ASV", by.y = "OTU")[, c(
    "Taxonomy", "guid", "mbNumber", "taxonomicLevel", "notes", "citationSource"
  ) := NULL]
}

exp_da_FUN  <- lapply(exp_da$FUN,  function(d) mergeFunguilds(d, funguilds))
time_da_FUN <- lapply(time_da$FUN, function(d) mergeFunguilds(d, funguilds))


# des_funguilds_filt <- function(data) {
#   # filt <- data[padj_X1 < 0.05 & padj_X2 < 0.05 & padj_inter > 0.05]
#   filt <- data#[!is.na(confidenceRanking) & confidenceRanking != "Possible"]
#   # filt[, c("log2FC_inter", "padj_inter", "sig_inter") := NULL]
#   filt[, correlation := ifelse(log2FC > 0, "positive", "negative")]
#   setorder(filt, log2FC)
#   split(filt, ~ source + correlation)
# }

# des_funguilds_filt(exp_da_FUN)
# des_funguilds_filt(time_da_FUN)

summariseFunguilds <- function(data) {
  data_clean <- data[!is.na(confidenceRanking) & confidenceRanking != "Possible"]

  # primary <- copy(data_clean)
  # primary[, primary := {
  #   m <- regexpr("\\|(.+?)\\|", guild)
  #   res <- regmatches(guild, m)
  #   res[which(m == -1)] <- NA
  #   res
  # }]
  # primary[, primary := gsub("\\|", "", primary)]
  # primary <- primary[!is.na(primary)]
  # primary_summary <- primary[, .(
  #   count = .N
  # ), by = primary][order(-count)]

  all <- copy(data_clean)
  all[, guild := gsub("\\|", "", guild)]
  split_list <- strsplit(all$guild, split = "-")
  indices <- rep(1:nrow(all), sapply(split_list, length))
  all_split <- all[indices]
  all_split[, guild := unlist(split_list)]
  all_summary <- all_split[, .(
    count = .N
    # proportion = .N / nrow(all_split),
  ), by = guild][order(-count)]

  # return(list(
  #   primary_guild_summary = primary_summary,
  #   all_guilds_summary = all_summary
  # ))
  all_summary
}

summariseFunguilds(exp_da_FUN$root[correlation == "positive"])

applyFunguilds <- function(data) {
  Map(function(source, dt) {
    split_data <- split(dt, f = ~ correlation)

    res <- lapply(names(split_data), function(cor) {
      guilds <- summariseFunguilds(split_data[[cor]])
      setnames(guilds, "count", cor)
      guilds
    })

    Reduce(function(x, y) merge(x, y, by = "guild", all = TRUE), res)

  }, names(data), data)
}

applyFunguilds(exp_da_FUN)#  |> printTable("Experiment")
applyFunguilds(time_da_FUN)# |> printTable("Timepoint")


```

### FAPROTAX

```{r FAPROTAX}

source(here("functional_analysis", "faprotax.R"))

fapro_dir <- here("/home/hmclean/apps/faprotax/FAPROTAX_1.2.12/")

apply_faprotaxit <- function(data, type) {
  split_data <- lapply(data, function(d) split(d, f = ~ correlation))
  
  Map(function(source, dt) {
    res <- lapply(names(dt), function(cor) {
      dt_subset <- dt[[cor]]
      fapro <- faprotaxit(
        BAC$taxData[dt_subset$ASV, ], 
        here("functional_analysis", paste("BAC", type, source, cor, "fapro.txt", sep = "_")),
        fapro_dir
      )
      setnames(fapro, "total_otus", cor)
      return(fapro)
    })
    Reduce(function(x, y) merge(x, y, by = "function_group", all = TRUE), res)
  }, names(split_data), split_data)
}

# apply_faprotaxit(exp_da$BAC, "exp")
# apply_faprotaxit(time_da$BAC, "time")


# faprotax <- list(
#   EXP = apply_faprotaxit(exp_da$BAC, "exp"),
#   TIME = apply_faprotaxit(time_da$BAC, "time")
# )

# faprotax

apply_faprotaxit(exp_da$BAC, "exp")#   |> printTable("Experiment")
apply_faprotaxit(time_da$BAC, "time")# |> printTable("Timepoint")

```