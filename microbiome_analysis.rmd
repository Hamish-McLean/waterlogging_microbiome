---
title: "Waterlogging microbiome analysis"
author: "Hamish McLean"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: TRUE
    toc_float: TRUE
    number_sections: TRUE
    theme: cerulean
    highlight: tango
params:
  alpha_cache: TRUE
  pipeline: "DADA2"
---

## Setup

```{r setup, include=FALSE}

if (!exists("params")) params <- list(pipeline = "DADA2")

knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, error = TRUE)

# Kable options
# options(
#   browser = "false",
#   kableExtra.html.bsTable = TRUE,
#   kableExtra.bootstrap_options = c("striped", "hover", "condensed"),
#   kableExtra_view_html = interactive(),
#   knitr.table.format = "html",
#   viewer = NULL # Disable viewer to avoid opening in browser
# )

# Sys.setenv("BROWSER" = "false")

```

```{r libraries}

library(buildmer)
library(car)
library(ComplexHeatmap)
library(cowplot)
library(data.table)
library(DESeq2)
library(dplyr)
library(DT)
library(emmeans)
library(ggpubr)
library(gplots)
library(gridExtra)
library(here)
library(kableExtra)
library(lmerTest)
library(lme4)
library(lmPerm)
library(partR2)
library(patchwork)
library(performance)
library(permutes)
library(ragg)
library(rstatix)
library(see)
library(stringr)
library(tidyr)
library(vegan)
library(viridis)

```

```{r functions}

here <- here::here()

FUNC_DIR <- here("functions")

source(here(FUNC_DIR, "functions.R"))
source(here(FUNC_DIR, "loadme.R"))
source(here(FUNC_DIR, "metabarcoding.R"))
source(here(FUNC_DIR, "metafuncs.R"))
source(here(FUNC_DIR, "rarefaction.R"))

# knit_print.datatable <- function(x, ...) {
#   htmltools::browsable(x)
# }

```

```{r constants}

DATA_DIR    <- normalizePath(here("..", "Data"))
FIGURES_DIR <- here("figures")
OBJECT_DIR  <- here("objects")

# Bioinformatics pipeline (defaults to DADA2)
# This should be set in the YAML header or passed as a parameter
PIPELINE    <- params$pipeline # DADA2 or USEARCH
ASV_FILTER  <- 0.001 # ASV filter for removing low abundance ASVs
READ_FILTER <- 0.05  # Read count filter for rarefaction
TAX_CONF    <- 0.80  # Confidence threshold for taxonomic rank assignment
SEED        <- 25647 # Random seed

alpha_cache <- params$alpha_cache

# Colour blind palette
cbPalette   <- c(
  "#000000", "#E69F00", "#56B4E9", "#009E73", 
  "#F0E442", "#0072B2", "#D55E00", "#CC79A7"
)

# Model designs
# Timepoint model for E1
T_DESIGN   <- ~ block + timepoint * treatment + Error(plot)
T_DESIGN_M <- ~ timepoint * treatment + (1 | plot)

# Experiment model without timepoint 2
E_DESIGN   <- ~ experiment:block + experiment * treatment
E_DESIGN_M <- ~ experiment * treatment + (1 | experiment:block)

```

## Load data

Load data from R objects.

```{r load data}

FUN  <- readRDS(here(OBJECT_DIR, "FUN.rds"))
BAC  <- readRDS(here(OBJECT_DIR, "BAC.rds"))

EXP  <- readRDS(here(OBJECT_DIR, "EXP.rds"))
TIME <- readRDS(here(OBJECT_DIR, "TIME.rds"))

```

## Community size

### Copy number plots

```{r copy number plots}

copyNumberPlot <- function(data, x) {
  ggboxplot(
    data,
    x = x,
    y = "log10_copy_number",
    color = "weeks", 
    # fill = "weeks",
    add = c("jitter"),
    # jitter.color = "weeks",
    # jitter.alpha = 0.1,
    # jitter.width = 0.1,
    facet.by = c("type", "source"),
    scales = "free",
    legend = "bottom"
    # palette = "jco"
  ) + labs(
    x = x,
    y = bquote(log[10] ~ "copy number")
  )
}

copy_number_combined <- rbind(
  FUN$colData %>% mutate(type = "Fungi"),
  BAC$colData %>% mutate(type = "Bacteria")
)

# Experiment
copyNumberPlot(filter(copy_number_combined, timepoint == 1), "experiment")
ggsave(filename = "CN_EXP.png", path = FIGURES_DIR)

# Timepoint
copyNumberPlot(filter(copy_number_combined, experiment == 1), "timepoint")
ggsave(filename = "CN_TIME.png", path = FIGURES_DIR)

```

### Copy number models

#### Linear mixed effects models

```{r copy number mixed models, eval = FALSE}

exp_cn  <- apply_to_subsets(EXP, copyNumberModelLMM, E_DESIGN_M) |> combineTables()
time_cn <- apply_to_subsets(TIME, copyNumberModelLMM, T_DESIGN_M) |> combineTables()

# exp_cn  [P <= 0.05 & factor != "(Intercept)"] |> printTable("Experiment")
# time_cn [P <= 0.05 & factor != "(Intercept)"] |> printTable("Timepoint")

# Full tables
exp_cn  |> printTable("Experiment")
time_cn |> printTable("Timepoint")


# lmer(update(E_DESIGN_M, copy_number ~ .), EXP$FUN$soil$colData) |> residuals() |> qqnorm()

```

#### Linear models

```{r copy number models}

# apply_to_subsets(EXP, copyNumberModelLM, E_DESIGN) |> combineTables()

# apply_to_subsets(TIME, copyNumberModelLM, T_DESIGN) |> combineTables()


# a <- aov(update(T_DESIGN, copy_number ~ .), TIME$FUN$soil$colData)
# ggqqplot(residuals(a))
# ggsave(filename = "test_plot.png", path = FIGURES_DIR)

# summary(a)

genericAnova <- function(data, kingdom, source, design) {
  anova    <- aov(design, data$colData)
  anova_df <- summary(anova)[[1]]
  total_ss <- sum(anova_df[["Sum Sq"]])
  data.table(
    kingdom = kingdom,
    source  = source,
    factor  = rownames(anova_df) |> trimws(),
    df      = anova_df[["Df"]],
    SS      = anova_df[["Sum Sq"]],
    MS      = anova_df[["Mean Sq"]],
    F       = anova_df[["F value"]],
    P       = anova_df[["Pr(>F)"]],
    stars   = p_stars(anova_df[["Pr(>F)"]]),
    ges     = anova_df[["Sum Sq"]] / total_ss
  )
}

exp_cn_lm <- apply_to_subsets(EXP, genericAnova, update(E_DESIGN, log10(copy_number) ~ .)) |> combineTables()

exp_cn_lm |> printTable("Experiment")

# apply_to_subsets(TIME, genericAnova, update(T_DESIGN, log10_copy_number ~ .)) |> combineTables()


timepointAnova <- function(data, kingdom, source, design) {
  anova     <- aov(update(design, log10(copy_number)  ~ .), data$colData)
  plot_df   <- summary(anova)[["Error: plot"]][[1]]
  # plot_ss   <- sum(plot_df[["Sum Sq"]])
  # plot_df$var <- plot_df[["Sum Sq"]] / plot_ss * 100
  within_df <- summary(anova)[["Error: Within"]][[1]]
  # within_ss <- sum(within_df[["Sum Sq"]])
  # within_df$var <- within_df[["Sum Sq"]] / within_ss * 100
  anova_df  <- bind_rows(plot_df, within_df)

  grand_mean <- mean(data$colData$log10_copy_number, na.rm = TRUE)
  total_ss   <- sum((data$colData$log10_copy_number - grand_mean)^2, na.rm = TRUE)
  data.table(
    kingdom = kingdom,
    source  = source,
    factor  = rownames(anova_df) |> trimws(),
    df      = anova_df[["Df"]],
    SS      = anova_df[["Sum Sq"]],
    MS      = anova_df[["Mean Sq"]],
    F       = anova_df[["F value"]],
    P       = anova_df[["Pr(>F)"]],
    stars   = p_stars(anova_df[["Pr(>F)"]]),
    ges     = anova_df[["Sum Sq"]] / total_ss
  )
}

# timepointAnova(TIME$FUN$soil, "Fungi", "soil", T_DESIGN)

time_cn_lm <- apply_to_subsets(TIME, timepointAnova, T_DESIGN) |> combineTables()

time_cn_lm |> printTable("Timepoint")

# t <- log10_copy_number ~ block + timepoint * treatment + Error(plot)

# lm(t, TIME$FUN$soil$colData)

# anova_test(
#   TIME$FUN$soil$colData, 
#   formula = log10_copy_number ~ block + timepoint * treatment,# + Error(plot),
#   # dv = log10_copy_number, 
#   # wid = plot,
#   # # between = c(block, treatment),
#   # within = timepoint,
#   type = 3,
#   effect.size = "res"
# )


# anova_test(
#   TIME$FUN$soil$colData, 
#   log10_copy_number ~ block + timepoint * treatment + Error(plot),
#   type = 3,
#   effect.size = "res"
# )


# emmeans
emmMain <- function(model, k, s, specs, section = NULL) {
  # dat <- data[[k]][[s]]$colData
  # model <- aov(update(design, log10(copy_number) ~ .), data$colData)
  emm <- emmeans(model, specs, type = "response") |> suppressMessages()
  # return(emm)
  res <- if(is.null(section)) emm else emm[[section]] |> as.data.frame()
  mutate(res, kingdom = k, source = s)
}

e_anova <- apply_to_subsets(
  EXP, function(data, k, s, design) aov(design, data$colData), 
  update(E_DESIGN, log10(copy_number) ~ .)
)

# t_anova <- apply_to_subsets(
#   TIME, function(data, k, s, design) aov(design, data$colData), 
#   update(T_DESIGN, log10(copy_number) ~ .)
# )

# emmMain(e_anova$FUN$root, "FUN", "root", pairwise ~ experiment, "contrasts", EXP)
# emmMain(t, "k", "s", pairwise ~ timepoint, "contrasts")
# emmMain(t_anova$FUN$root, "k", "s", pairwise ~ timepoint, "contrasts", TIME)
# emmMain(t_anova$FUN$root, "FUN", "root", ~ timepoint, data = TIME)


# Experiment
# All experiment contrasts
apply_to_subsets(e_anova, emmMain, pairwise ~ experiment, "emmeans") |> 
  combineTables() |> printTable("Experiment")
apply_to_subsets(e_anova, emmMain, pairwise ~ experiment, "contrasts") |> 
  combineTables() |> printTable("Experiment")

# Timepoint
# All timepoint contasts
# apply_to_subsets(TIME, emmMain, T_DESIGN, pairwise ~ timepoint, "emmeans") |> combineTables()
# apply_to_subsets(t_anova, emmMain, pairwise ~ timepoint, "contrasts", TIME) |> combineTables()

# apply_to_subsets(t_anova, emmMain, ~ timepoint, data = TIME) |> combineTables()

# emmMain <- function(data, k, s, design, specs, section = NULL) {
#   model <- aov(design, data$colData)
#   emm <- emmeans(model, specs, type = "response") |> suppressMessages()
#   return(emm)
#   # return(emm)
#   res <- if(is.null(section)) emm else emm[[section]] |> as.data.frame()
#   mutate(res, kingdom = k, source = s)
# }


t_design <- update(T_DESIGN, log10(copy_number) ~ .)

# emmMain(TIME$FUN$soil, "FUN", "soil", t_design, pairwise ~ timepoint)

emmeans(aov(t_design, TIME$FUN$soil$colData), pairwise ~ timepoint, type = "response")
emmeans(aov(t_design, TIME$BAC$root$colData), pairwise ~ timepoint, type = "response")
emmeans(aov(t_design, TIME$FUN$soil$colData), pairwise ~ timepoint, type = "response")
emmeans(aov(t_design, TIME$BAC$root$colData), pairwise ~ timepoint, type = "response")




# e <- aov(update(E_DESIGN, log10(copy_number) ~ .), EXP$FUN$soil$colData)

# emmeans(e, ~ experiment, type = "response")
# emmeans(e, pairwise ~ experiment, type = "response")
# emmeans(e, pairwise ~ treatment|experiment, type = "response")
# emmeans(e, trt.vs.ctrl ~ treatment|experiment, type = "response")
# emmeans(e, specs = "experiment", by = "treatment", type = "response")


# t <- aov(update(T_DESIGN, log10(copy_number) ~ .), TIME$FUN$soil$colData)

# emmeans(t, ~ timepoint, type = "response")
# emmeans(t, pairwise ~ timepoint, type = "response")
# emmeans(t, pairwise ~ treatment|timepoint, type = "response")
# emmeans(t, trt.vs.ctrl ~ treatment|timepoint, type = "response")


```

## Alpha diversity

### Calculate alpha diversity

Add alpha diversity idices to data objects.

```{r calculate alpha diversity}

EXP  <- apply_to_subsets(EXP, calculateAlpha)
TIME <- apply_to_subsets(TIME, calculateAlpha)

```

### Permutation anova of alpha diversity index ranks

`perm.lmer` runs a permutation test for mixed-effects models.
This model takes a long time to run, so results are cached.

```{r alpha diversity analysis, eval = FALSE}

# These models are very slow, only run to update the cached results
if (!alpha_cache) {
  # Define metrics
  metrics <- c("S.chao1", "shannon", "simpson")

  exp_alpha  <- apply_to_subsets(EXP, alphaModel, metrics, E_DESIGN_M) |> combineTables()
  time_alpha <- apply_to_subsets(TIME, alphaModel, metrics, T_DESIGN_M) |> combineTables()

  saveRDS(exp_alpha,  here(OBJECT_DIR, "exp_alpha.rds"))
  saveRDS(time_alpha, here(OBJECT_DIR, "time_alpha.rds"))
} else {
  exp_alpha  <- readRDS(here(OBJECT_DIR, "exp_alpha.rds"))
  time_alpha <- readRDS(here(OBJECT_DIR, "time_alpha.rds"))
}

# exp_alpha [p <= 0.05 & factor != "(Intercept)"] |> printTable()
# time_alpha[p <= 0.05 & factor != "(Intercept)"] |> printTable()

# Full tables
exp_alpha  |> printTable()
time_alpha |> printTable()

```

#### Alpha post-hoc (LMM)

```{r alpha post-hoc LMM, eval = FALSE}

# EXP FUN root Simpson: NS, mean(simpson) slightly higher in treated for both
alphaPostHoc(EXP$FUN$root$alphaData, "simpson", formula(~ treatment + (1 | block)), "experiment")

# EXP FUN soil Chao1: NS, mean(Chao1) slighly higher in E1 trt, lower in E2 trt 
alphaPostHoc(EXP$FUN$soil$alphaData, "S.chao1", formula(~ treatment + (1 | block)), "experiment")

# EXP BAC soil Simpson: NS, mean(Simpson) slightly lower in treated for both
alphaPostHoc(EXP$BAC$soil$alphaData, "simpson", formula(~ treatment + (1 | block)), "experiment")



# TIME FUN soil Simpson: T1 ns, T2 *, higher in treated
alphaPostHoc(TIME$FUN$soil$alphaData, "simpson", formula(~ treatment + (1 | block)), "timepoint")

# TIME FUN soil Shannon: both ns, both lower in treated
alphaPostHoc(TIME$FUN$soil$alphaData, "shannon", formula(~ treatment + (1 | block)), "timepoint")

# TIME BAC root Chao1: both ns, 
alphaPostHoc(TIME$BAC$root$alphaData, "S.chao1", formula(~ treatment + (1 | block)), "timepoint")

# TIME BAC soil Simpson: T1 ns, T2 *, lower in treated
alphaPostHoc(TIME$BAC$soil$alphaData, "simpson", formula(~ treatment + (1 | block)), "timepoint")

```

### Alpha diversity linear models

```{r alpha LM}

metrics <- c("S.chao1", "shannon", "simpson")

# aovp(update(E_DESIGN, rank(shannon) ~ .), EXP$FUN$soil$alphaData) |> summary()

# alphaLM(EXP$FUN$soil, "FUN", "soil", metrics, E_DESIGN)

exp_alpha <- apply_to_subsets(EXP, alphaLM, metrics, E_DESIGN)

exp_alpha |> combineTables() |> printTable("Experiment")

# alphaLM(TIME$FUN$soil, "FUN", "soil", metrics, T_DESIGN)

singleAlphaLM <- function(data, kingdom, source, metric, design) {
  formula <- update(design, as.formula(paste0("rank(", metric, ") ~ .")))
  anova <- aovp(formula, data, seqs = TRUE)
  anova_df <- bind_rows(
    summary(anova)[["Error: plot"]][[1]] |> as.data.frame(), 
    summary(anova)[["Error: Within"]][[1]] |> as.data.frame()
  )
  metric_rank <- rank(data[[metric]])
  anova_df$met <- metric
  anova_df$factor <- rownames(anova_df) |> trimws()
  anova_df$total_ss <- sum((metric_rank - mean(metric_rank))^2)
  data.table(
    kingdom = kingdom,
    source  = source,
    metric  = anova_df$met,
    factor  = anova_df$factor,
    df      = anova_df[["Df"]],
    SS      = anova_df[["R Sum Sq"]],
    MS      = anova_df[["R Mean Sq"]],
    Iter    = anova_df[["Iter"]],
    p       = anova_df[["Pr(Exact)"]],
    stars   = p_stars(anova_df[["Pr(Exact)"]]),
    var     = anova_df[["R Sum Sq"]] / anova_df$total_ss * 100
  )
}

# singleAlphaLM(TIME$FUN$soil$alphaData, "FUN", "soil", "S.chao1", T_DESIGN)

time_alpha <- list(
  FUN = list(
    root = bind_rows(
      singleAlphaLM(TIME$FUN$root$alphaData, "FUN", "root", "S.chao1", T_DESIGN),
      singleAlphaLM(TIME$FUN$root$alphaData, "FUN", "root", "shannon", T_DESIGN),
      singleAlphaLM(TIME$FUN$root$alphaData, "FUN", "root", "simpson", T_DESIGN)
    ),
    soil = bind_rows(
      singleAlphaLM(TIME$FUN$root$alphaData, "FUN", "soil", "S.chao1", T_DESIGN),
      singleAlphaLM(TIME$FUN$root$alphaData, "FUN", "soil", "shannon", T_DESIGN),
      singleAlphaLM(TIME$FUN$root$alphaData, "FUN", "soil", "simpson", T_DESIGN)
    )
  ),
  BAC = list(
    root = bind_rows(
      singleAlphaLM(TIME$BAC$root$alphaData, "BAC", "root", "S.chao1", T_DESIGN),
      singleAlphaLM(TIME$BAC$root$alphaData, "BAC", "root", "shannon", T_DESIGN),
      singleAlphaLM(TIME$BAC$root$alphaData, "BAC", "root", "simpson", T_DESIGN)
    ),
    soil = bind_rows(
      singleAlphaLM(TIME$BAC$root$alphaData, "BAC", "soil", "S.chao1", T_DESIGN),
      singleAlphaLM(TIME$BAC$root$alphaData, "BAC", "soil", "shannon", T_DESIGN),
      singleAlphaLM(TIME$BAC$root$alphaData, "BAC", "soil", "simpson", T_DESIGN)
    )
  )
)

time_alpha |> combineTables() |> printTable("Timepoint")


# Summary tables

summariseAlpha <- function(data) {
  combined_data <- combineTables(data)
  combined_data$factor <- factor(combined_data$factor, levels = unique(combined_data$factor))
  dt <- dcast(
    combined_data,
    kingdom + factor + df ~ source + metric,
    value.var = c("var", "stars")
  )
  id_cols <- c("kingdom", "factor", "df")
  all_cols <- setdiff(names(dt), id_cols)
  base_cols <- unique(sub("^(var|stars)_", "", all_cols))
  final_cols <- c(
    id_cols,
    as.vector(sapply(base_cols, function(x) c(paste0("var_", x), paste0("stars_", x))))
  )
  setcolorder(dt, final_cols)
  dt
}

summariseAlpha(exp_alpha)  |> printTable("Experiment")
summariseAlpha(time_alpha) |> printTable("Timepoint")

# combineTables(exp_alpha)$factor |> as.ordered()


# Post hoc analysis

# Bacteria soil Simpson
# dat <- EXP$BAC$soil$alphaData
# dat$simpson_rank <- rank(dat$simpson)
# ## E1
# dat[experiment == 1]$simpson_rank |> mean()
# ##E2
# dat[experiment == 2]$simpson_rank |> mean()

# emmeans(
#   aovp(update(E_DESIGN, rank(simpson) ~ .), dat, seqs = TRUE)
# )

# pairwise.wilcox.test(
#   x = dat$simpson_rank, # Your response variable
#   g = dat$experiment,       # Your grouping factor
#   p.adjust.method = "bonferroni"
# )

# anovaResults <- function(data, k, s, design) {
#   anova <- aovp(update(design, measure ~ .))
#   anova_df <- if (length(anova) > 3) { # length = 3 for repeat measures anova
#     summary(anova)[[1]] # anova |> data.frame()
#   } else {
#     bind_rows(
#       summary(anova)[["Error: plot"]][[1]], 
#       summary(anova)[["Error: Within"]][[1]]
#     )
#   }
#   # total_ss <- sum(anova_df["Sum Sq"])
#   total_ss <- sum((pc_dat - mean(pc_dat))^2)
#   data.table(
#     kingdom = kingdom,
#     source  = source,
#     pc      = pc_name,
#     factor  = rownames(anova_df) |> trimws(),
#     df      = anova_df[["Df"]],
#     SS      = anova_df[["Sum Sq"]],
#     MS      = anova_df[["Mean Sq"]],
#     F       = anova_df[["F value"]],
#     P       = anova_df[["Pr(>F)"]],
#     var     = anova_df[["Sum Sq"]] / total_ss * 100
#   )
# }

```

#### Alpha diversity post-hoc (linear models)

```{r alpha post-hoc (LM)}

# Compare means between experiments

alphaPostHoc <- function(data, kingdom, source, metrics, factor, lvl) {
  dt  <- data$alphaData
  for (met in metrics) dt[, (paste0(met, "_rank")) := rank(get(met))]
  ranks <- sapply(metrics, function(met) paste0(met, "_rank"))
  res <- data.table(
    Kingdom = kingdom,
    Source  = source,
    Metric  = metrics
  )
  res[, (paste(factor, lvl[1])) := sapply(ranks, function(m) mean(dt[get(factor) == lvl[1]][[m]]))]
  res[, (paste(factor, lvl[2])) := sapply(ranks, function(m) mean(dt[get(factor) == lvl[2]][[m]]))]
  res[, diff := get(paste(factor, lvl[2])) - get(paste(factor, lvl[1]))]
}

# Experiment
apply_to_subsets(EXP, alphaPostHoc, metrics, "experiment", c(1, 2)) |> combineTables() |> printTable("Experiment")
apply_to_subsets(EXP, alphaPostHoc, metrics, "treatment", c(0, 1)) |> combineTables() |> printTable("Experiment: treatment")

# Timepoint
apply_to_subsets(TIME, alphaPostHoc, metrics, "timepoint", c(1, 2)) |> combineTables() |> printTable("Timepoint")
apply_to_subsets(TIME, alphaPostHoc, metrics, "treatment", c(0, 1)) |> combineTables() |> printTable("Timepoint: treatment")


# Interactions

alphaEach <- function(data, kingdom, source, metrics, design, type) {
  cat(paste0("\nAnalyzing alpha diversity for ", kingdom, ": ", source, "\n"))

  # Subset data
  data_subsets <- split(data$alphaData, as.formula(paste("~", type)))

  # Run alpha diversity analysis for each metric
  anova_results <- list()

  for (met in metrics) {
    formula <- update(design, as.formula(paste0("rank(", met, ") ~ .")))

    # anova <- lapply(data_subsets, function(d) aovp(formula, data = d, seqs = TRUE))
    df_list <- lapply(data_subsets, function(d) {
      anova <- aovp(formula, data = d, seqs = TRUE)
      df <- summary(anova)[[1]] |> as.data.frame()
      setDT(df, keep.rownames = "factor")
      df[, total_ss := sum((rank(d[[met]]) - mean(rank(d[[met]])))^2)]
    })

    anova_df <- rbindlist(df_list, idcol = type)
    anova_df$metric <- met
    
    anova_results[[met]] <- anova_df
  }

  results <- rbindlist(anova_results)

  results[, var := get("R Sum Sq") / total_ss * 100]
  # return(results)
  data.table(
    kingdom = kingdom,
    source  = source,
    type    = results[[type]],
    metric  = results$metric,
    factor  = results$factor,
    df      = results[["Df"]],
    SS      = results[["R Sum Sq"]],
    MS      = results[["R Mean Sq"]],
    p       = results[["Pr(Exact)"]],
    stars   = p_stars(results[["Pr(Exact)"]]),
    var     = results[["R Sum Sq"]] / results$total_ss * 100
  ) %>% setnames(old = "type", new = type)
}

design <- ~ block + treatment

# alphaEach(EXP$FUN$soil, "kingdom", "source", metrics, design, "experiment") |> print()

exp_alpha_each  <- apply_to_subsets(EXP, alphaEach, metrics, design, "experiment")
time_alpha_each <- apply_to_subsets(TIME, alphaEach, metrics, design, "timepoint")

exp_alpha_each  |> combineTables() |> printTable("Experiment")
time_alpha_each |> combineTables() |> printTable("Timepoint")

combineTables(exp_alpha_each)[p < 0.05]
combineTables(time_alpha_each)[p < 0.05]

## EXP FUN root simpson & soil Chao1
## EXP BAC root all & soil Chao1 Simpson
## TIME BAC root Chao1 soil Chao1

summariseAlphaEach <- function(data) {
  combined_data <- combineTables(data)
  combined_data$factor <- factor(combined_data$factor, levels = unique(combined_data$factor))
  dt <- dcast(
    combined_data,
    kingdom + factor + df ~ source + metric + experiment,
    value.var = c("var", "stars")
  )
  id_cols <- c("kingdom", "factor", "df")
  all_cols <- setdiff(names(dt), id_cols)
  base_cols <- unique(sub("^(var|stars)_", "", all_cols))
  final_cols <- c(
    id_cols,
    as.vector(sapply(base_cols, function(x) c(paste0("var_", x), paste0("stars_", x))))
  )
  setcolorder(dt, final_cols)
  dt
}

summariseAlphaEach(exp_alpha_each)  |> printTable("Experiment")
summariseAlphaEach(time_alpha_each) |> printTable("Timepoint")


alphaPostHocEach <- function(data, kingdom, source, metrics, type) {
  # Split data
  split_data <- split(data$alphaData, as.formula(paste("~", type)))
  # Calculate ranks for each data split 
  for (m in metrics) sapply(split_data, function(dt) dt[, (m) := rank(get(m))])
  group_cols <- c("source", "experiment", "timepoint", "treatment")
  # Summarise by treatment and reformat
  rank_means <- lapply(split_data, function(dt) {
    dt[, lapply(.SD, mean), by = group_cols, .SDcols = metrics] %>%
      melt(id.vars = group_cols, measure_vars = metrics, variable.name = "metric") %>%
      dcast(source + experiment + timepoint + metric ~ treatment, value.var = "value")
  }) |> rbindlist()

  data.table(
    Kingdom    = kingdom,
    Source     = rank_means$source,
    Experiment = rank_means$experiment,
    Timepoint  = rank_means$timepoint,
    Metric     = rank_means$metric,
    Trt_0      = rank_means$'0',
    Trt_1      = rank_means$'1',
    diff       = rank_means$'1' - rank_means$'0'
  )
}

# alphaPostHocEach(EXP$FUN$soil, "FUN", "soil", metrics, "experiment") |> print()

apply_to_subsets(EXP, alphaPostHocEach, metrics, "experiment") |> combineTables() |> printTable()
apply_to_subsets(TIME, alphaPostHocEach, metrics, "timepoint") |> combineTables() |> printTable()

```

### Alpha diversity plots

```{r alpha diversity plots}

measures <- c("Chao1", "Shannon", "Simpson")

plotAlpha <- function(data, k, s, measures, design) {
  plot_alpha(
    data$countData, data$colData,
    design = design, colour = "weeks",
    measures = measures,
    type = "box"
  ) + scale_colour_manual(values = cbPalette) +
    # theme(axis.title.x = element_blank()) +
    ggtitle(paste(k, ":", s))
}

exp_alpha_plots <- apply_to_subsets(EXP, plotAlpha, measures, "experiment") |> unlist(FALSE)

# ggarrange(exp_alpha_plots, ncol = 2, common.legend = TRUE, legend = "bottom")

# plot_grid(
#   plotlist = exp_alpha_plots,
#   align = "h",
#   ncol = 2
# )

(exp_alpha_plots[[1]] + exp_alpha_plots[[2]]) / (exp_alpha_plots[[3]] + exp_alpha_plots[[4]]) +
  plot_layout(guides = "collect") & # Collect legends into a single common legend
  theme(legend.position = "bottom") # Position the common legend

ggsave("alpha_EXP.png", path = FIGURES_DIR)


time_alpha_plots <- apply_to_subsets(TIME, plotAlpha, measures, "timepoint") |> unlist(FALSE)

(time_alpha_plots[[1]] + time_alpha_plots[[2]]) / (time_alpha_plots[[3]] + time_alpha_plots[[4]]) +
  plot_layout(guides = "collect") & # Collect legends into a single common legend
  theme(legend.position = "bottom") # Position the common legend

ggsave("alpha_TIME.png", path = FIGURES_DIR)

```

## Beta diversity: Bray-Curtis

### PERMANOVA of Bray-Curtis dissimilarity

Block included as a main effect in the design formula.

```{r adonis}

# Designs for ADONIS
# e_design <- vg ~ experiment/block * treatment

t_design <- vg ~ block + timepoint * treatment


# Apply adonis analysis to each subset of data
exp_bc  <- apply_to_subsets(EXP, adonisModel, update(E_DESIGN, vg ~ .)) |> combineTables()

time_bc <- apply_to_subsets(TIME, adonisModel, t_design, "plot") |> combineTables()

# exp_bc[P < 0.05]  |> printTable()
# time_bc[P < 0.05] |> printTable()

# Full tables
exp_bc  |> printTable("Experiment")
time_bc |> printTable("Timepoint")

```

#### Post-hoc analysis

```{r adonis post-hoc}

#' @title Post-hoc analysis for adonis2 interaction terms
#' @description Splits data by a grouping variable and runs a simplified
#'   adonis2 model on each subset to investigate a significant interaction.
#' @param data A data.frame or data.table containing the experiment metadata.
#' @param counts A matrix or data.frame of raw or normalized counts (e.g., from DESeq2).
#' @param simplified_formula A formula object for the fixed effects of the simplified model (e.g., `~ treatment`).
#' @param group_by_var A string representing the column name to split the data by (e.g., "experiment" or "timepoint").
#' @param nperm The number of permutations to use for adonis2.
#' @return A list of the adonis2 results (data.tables) for each subset.
#' 
adonisPostHoc <- function(data, kingdom, source, design, type, nperm = 1000) {

  # Split the data into a list of data.tables based on the grouping variable
  split_data <- split(data$colData, as.formula(paste("~", type)))

  # Initialize a list to store the results
  adonis_results <- list()

  # Iterate through each subset of the data
  for (group_name in names(split_data)) {
    subset_data <- split_data[[group_name]]

    # Subset the counts matrix to match the current metadata subset
    subset_counts <- counts(data$dds, normalize = TRUE)[, rownames(subset_data)]

    # Calculate Bray-Curtis distances for the subset
    vg <- vegdist(t(subset_counts), method = "bray")

    message(paste("Running adonis2 for", type, group_name))

    # Run adonis2 on the subset
    model_result <- tryCatch({
      vegan::adonis2(
        update(design, vg ~ .),
        data = subset_data,
        permutations = nperm,
        by = "terms"
      )
    }, error = function(e) {
      warning(paste("Error running adonis2 for", type, group_name, ":", e$message))
      NULL
    })

    # Convert the adonis2 output to a data.frame for easier handling and store it
    if (!is.null(model_result)) {
      df <- as.data.frame(model_result)
      total_ss <- df["Total", "SumOfSqs"]
      # setDT(df, keep.rownames = "factor")
      adonis_results[[group_name]] <- data.table(
        kingdom = kingdom,
        source  = source,
        type    = group_name,
        factor  = rownames(df),
        df      = df$Df,
        SS      = df$SumOfSqs,
        R2      = df$R2,
        F       = df$F,
        P       = df$'Pr(>F)',
        stars   = p_stars(df$'Pr(>F)'),
        var     = df$SumOfSqs / total_ss * 100
      ) %>% setnames(old = "type", new = type)
    }
  }

  rbindlist(adonis_results)
}

design <- ~ block + treatment

adonisPostHoc(EXP$FUN$soil, "FUN", "soil", design, "experiment")#

exp_bc_each  <- apply_to_subsets(EXP, adonisPostHoc, design, "experiment")
time_bc_each <- apply_to_subsets(TIME, adonisPostHoc, design, "timepoint")

combineTables(exp_bc_each)[P < 0.05]
combineTables(time_bc_each)[P < 0.05]

```

### Bray-Curtis NMDS plots

```{r nmds}

set.seed(SEED)

# Experiment

nmds_exp_fun_root <- nmdsPlot(EXP$FUN$root$dds, shape = "experiment", filename = "NMDS_FUN_root_exp.png")
nmds_exp_fun_soil <- nmdsPlot(EXP$FUN$soil$dds, shape = "experiment", filename = "NMDS_FUN_soil_exp.png")
nmds_exp_bac_root <- nmdsPlot(EXP$BAC$root$dds, shape = "experiment", filename = "NMDS_BAC_root_exp.png")
nmds_exp_bac_soil <- nmdsPlot(EXP$BAC$soil$dds, shape = "experiment", filename = "NMDS_BAC_soil_exp.png")

nmds_exp_combined <- ggarrange(
  plotlist = list(nmds_exp_fun_root, nmds_exp_fun_soil, nmds_exp_bac_root, nmds_exp_bac_soil),
  common.legend = TRUE,
  legend = "bottom",
  labels = c("Fungi: roots", "Fungi: soil", "Bacteria: roots", "Bacteria: soil")
)
nmds_exp_combined
ggsave("NMDS_exp.png", plot = nmds_exp_combined, path = FIGURES_DIR)

# Timepoint

nmds_time_fun_root <- nmdsPlot(TIME$FUN$root$dds, shape = "timepoint", filename = "NMDS_FUN_root_time.png")
nmds_time_fun_soil <- nmdsPlot(TIME$FUN$soil$dds, shape = "timepoint", filename = "NMDS_FUN_soil_time.png")
nmds_time_bac_root <- nmdsPlot(TIME$BAC$root$dds, shape = "timepoint", filename = "NMDS_BAC_root_time.png")
nmds_time_bac_soil <- nmdsPlot(TIME$BAC$soil$dds, shape = "timepoint", filename = "NMDS_BAC_soil_time.png")

nmds_time_combined <- ggarrange(
  plotlist = list(nmds_time_fun_root, nmds_time_fun_soil, nmds_time_bac_root, nmds_time_bac_soil),
  common.legend = TRUE,
  legend = "bottom",
  labels = c("Fungi: roots", "Fungi: soil", "Bacteria: roots", "Bacteria: soil")
)
nmds_time_combined
ggsave("NMDS_time.png", plot = nmds_time_combined, path = FIGURES_DIR)

```

## Beta diversity: PCA

### PCA models

```{r pca}

# Calculate PCA
EXP  <- apply_to_subsets(EXP, calculatePCA)
TIME <- apply_to_subsets(TIME, calculatePCA)


# EXP PC percent variance 
lapply(unlist(EXP, FALSE), function(x) {
  unlist(round(x$pca$percentVar * 100, 2))
}) |> as.data.table() |> mutate("PC" = 1:20) |> printTable()

# TIME PC percent variance
lapply(unlist(TIME, FALSE), function(x) {
  unlist(round(x$pca$percentVar * 100, 2))
}) |> as.data.table() |> mutate("PC" = 1:20) |> printTable()


# e_design <- ~ treatment * experiment + experiment:block
# t_design <- ~ treatment * timepoint

# EXP PCA linear model
e_pca_lm <- apply_to_subsets(EXP, pcaLM, E_DESIGN, "experiment")
e_pca_lm |> combineTables() |> filter(P <= 0.05 & factor != "(Intercept)") |> printTable()

# TIME PCA linear model
t_pca_lm <- apply_to_subsets(TIME, pcaLM, T_DESIGN, "timepoint")
t_pca_lm |> combineTables() |> filter(P <= 0.05 & factor != "(Intercept)") |> printTable()


#' Summarise PCA results by adjusted variance %
pcaLMVar <- function(data, k, s) {
  data[, .(var_adj = sum(var_adj)), by = .(kingdom, source, factor, df)]
}

apply_to_subsets(e_pca_lm, pcaLMVar) |> combineTables() |> printTable("Experiment")
apply_to_subsets(t_pca_lm, pcaLMVar) |> combineTables() |> printTable("Timepoint")


# # EXP PCA linear mixed model
# apply_to_subsets(EXP, pcaLMM, E_DESIGN_M) |> combineTables() |> 
#   filter(P <= 0.05 & factor != "(Intercept)") |> printTable()

# # TIME PCA linear mixed model
# apply_to_subsets(TIME, pcaLMM, T_DESIGN_M) |> combineTables() |> 
#   filter(P <= 0.05 & factor != "(Intercept)") |> printTable()


# First x PCs
pcaSummary <- function(data, k, s, n_pcs) {
  pcs <- paste0("PC", n_pcs)
  subset <- data[pc %in% pcs]
  subset[, stars := p_stars(P)]
  subset[, factor := factor(factor, levels = unique(factor))]
  dt <- dcast(
    subset,
    kingdom + source + factor + df ~ pc,
    value.var = c("F", "P", "var_adj", "stars")
  )
  id_cols <- c("kingdom", "source", "factor", "df")
  all_cols <- setdiff(names(dt), id_cols)
  base_cols <- unique(sub("^(F|P|var_adj|stars)_", "", all_cols))
  final_cols <- c(
    id_cols,
    as.vector(sapply(base_cols, function(x) c(
      paste0("F_", x), paste0("P_", x), 
      paste0("var_adj_", x), paste0("stars_", x)
    )))
  )
  setcolorder(dt, final_cols)
}

# pcaSummary(e_pca_lm$FUN$soil, "k", "s", 1:3) |> print()

pcs <- 1:4

apply_to_subsets(e_pca_lm, pcaSummary, pcs) |> combineTables() |> printTable("Expeiriment")
apply_to_subsets(t_pca_lm, pcaSummary, pcs) |> combineTables() |> printTable("Timepoint")

```

PCs of interest:

Experiment

- Fungi root: PC8 (int), PC9 (trt)

- Fungi soil: PC6 (trt, exp, & int)

- Bacteria root: PC7 (trt & int), PC8 (trt)

- Bacteria soil: PC3 (trt), PC4 (trt), PC8 (int), PC11 (trt), PC18 (int)

Timepoint

- Fungi root: PC4 (trt), PC5 (trt), PC10 (trt)

- Fungi soil: PC6 (int), PC7 (trt)

- Bacteria root: PC5 (trt, int), PC7 (trt, int), PC11 (int), PC12 (int)

- Bacteria soil: PC5 (trt, time, int), PC15(time, int)


### PC plots

```{r pc plots}

# EXP FUN root PCs 8 & 9
pcaPlot(EXP$FUN$root, c(8, 9), "experiment", "PCA_EXP_FUN_root_PC8-9.png")

# pcaPlot(EXP$FUN$soil, c(6), "experiment", "PCA_EXP_FUN_soil_PC6.png")

# EXP BAC root PCs 7 & 8
pcaPlot(EXP$BAC$root, c(7, 8), "experiment", "PCA_EXP_BAC_root_PC7-8.png")

# EXP BAC soil PCs 3 & 4
pcaPlot(EXP$BAC$soil, c(3, 4), "experiment", "PCA_EXP_BAC_soil_PC3-4.png")

# EXP BAC soil PCs 8 & 11
pcaPlot(EXP$BAC$soil, c(8, 11), "experiment", "PCA_EXP_BAC_soil_PC8-11.png")


# TIME FUN 

```

Insights

EXP FUN root PCs 8 & 9

EXP BAC root PCs 7 & 8
  PC7 exp 1 lest

### PC loadings

```{r pc loadings}

# PC loadings
pcLoadings <- function(data, pc, top_n = 10) {
  df <- cbind(PC = data$pca$x[, pc], data$colData)
  aggregate(PC ~ treatment, df, mean) |> print()

  loadings <- data$pca$rotation[, pc]
  top_asvs <- names(sort(abs(loadings), decreasing = TRUE))[1:top_n]
  data.table(
    PC = pc,
    ASVs = top_asvs,
    loading = loadings[top_asvs],
    taxa = data$taxData[top_asvs, ]$rank
  )
}

# Fungi root PC8
pcLoadings(EXP$FUN$root, 8, 10) |> printTable()

# Fungi root PC8
pcLoadings(EXP$FUN$root, 9, 10) |> printTable()

# Fungi soil PC6
pcLoadings(EXP$FUN$soil, 6, 10) |> printTable()


# Bacteria root PC7
pcLoadings(EXP$BAC$root, 7, 10) |> printTable()

# Bacteria soil PC4
pcLoadings(EXP$BAC$soil, 4, 10) |> printTable()

# Bacteria soil PC8
pcLoadings(EXP$BAC$soil, 8, 10) |> printTable()

```

Note: Multiply absolute loading by proportion of variance in PC explained by treatment
can then multiply this by proportion of variance of PC to the total community


## Differential abundance

```{r differential abundance}

# Run DESeq model
deseqModel <- function(data, k, s, design) {
  design(data$dds) <- design
  data$dds <- DESeq(data$dds)
  data
}

# Treatment effect with interaction

# e_design <- ~ experiment/block + treatment + experiment:treatment
# t_design <- ~ timepoint + block + treatment + timepoint:treatment

# EXP  <- apply_to_subsets(EXP, deseqModel, e_design)
# TIME <- apply_to_subsets(TIME, deseqModel, t_design)

# resultsNames(EXP$FUN$soil$dds)


# Overall treatment effect

e_design <- ~ experiment/block  + treatment
# t_design <- ~ timepoint + block + treatment

EXP  <- apply_to_subsets(EXP,  deseqModel, e_design)
# TIME <- apply_to_subsets(TIME, deseqModel, t_design)

# resultsNames(EXP$FUN$soil$dds)


# Differential abundance

exp_da  <- apply_to_subsets(EXP, diffAbundanceOverall, "experiment")
# time_da <- apply_to_subsets(TIME, diffAbundanceOverall, "timepoint")


# Analysis per timepoint

design <- ~ block + treatment
time_da <- apply_to_subsets(TIME, diffAbundancePerTimepoint, design)


# exp_da <- split(
#   apply_to_subsets(EXP, diffAbundanceOverall, "experiment") |> combineTables(),
#   f = ~ kingdom
# )

# time_da <- split(
#   apply_to_subsets(TIME, diffAbundanceOverall, "timepoint") |> combineTables(),
#   f = ~ kingdom
# )

# ASV count
cat("Total significant Fungal ASVs: ")
append(bind_rows(exp_da$FUN)$ASV, bind_rows(time_da$FUN)$ASV) |> unique() |> length()

cat("Total significant Bacterial ASVs: ")
append(bind_rows(exp_da$BAC)$ASV, bind_rows(time_da$BAC)$ASV) |> unique() |> length()


printDiffStats <- function(data, type) {
  kingdom <- ifelse(type == "FUN", "Fungal", "Bacterial")
  cat(
    "", kingdom, "soil: ", length(data[[type]]$soil$ASV),
    "\n", kingdom, "root: ", length(data[[type]]$root$ASV),
    "\n", kingdom, "both: ", length(intersect(data[[type]]$soil$ASV, data[[type]]$root$ASV)), "\n"
  )
}

```

### Differential abundance tables {.tabset}

#### EXP: FUN

```{r}
printDiffStats(exp_da, "FUN")
exp_da$FUN |> bind_rows() |> printTable()
```

#### EXP: BAC

```{r}
printDiffStats(exp_da, "BAC")
exp_da$BAC |> bind_rows() |> printTable()
```

#### TIME: FUN

```{r}
printDiffStats(time_da, "FUN")
time_da$FUN |> bind_rows() |> printTable()
```

#### TIME: BAC

```{r}
printDiffStats(time_da, "FUN")
time_da$BAC |> bind_rows() |> printTable()
```

### Differential abundance subsets

```{r}

bind_rows(exp_da$FUN)  |> select("taxa") |> table() |> as.data.table() |> printTable()
bind_rows(time_da$FUN) |> select("taxa") |> table() |> as.data.table() |> printTable()

bind_rows(exp_da$FUN)[grepl("Dactylonectria", taxa)] |> printTable()
bind_rows(time_da$FUN)[grepl("Pleosporales", taxa)]  |> printTable()


bind_rows(exp_da$BAC)  |> select("taxa") |> table() |> as.data.table() |> printTable()
bind_rows(time_da$BAC) |> select("taxa") |> table() |> as.data.table() |> printTable()

bind_rows(time_da$BAC)[grepl("Oxalobacteraceae", taxa)] |> printTable()

```

The fungal taxa with multiple occurences (but different ASVs) had wildly different
results.
There were fewer bacteria with multiple occurences, but the results were more consistant.


### Differential abundace at genus level

- Filter dds by genus at 50% confidence
- Group by genus
- Run DESeq analysis on genus counts

```{r}

# Filter dds by genus at 50% confidence

diffAbundanceGenus <- function(data, k, s, sample_min = 4, tax_conf = 0.5) {
  # Filter ASVs with genus at tax_conf confidence
  taxData <- data$taxData[data$taxData$g_conf >= tax_conf, ]
  countData <- counts(data$dds)[rownames(taxData), ]

  # Sum counts per genus
  countData <- rowsum(countData, group = taxData$genus)

  # Filter Genera present in >= sample_min samples
  countData <- countData[rowSums(countData > 0) >= sample_min, ]
  taxData <- taxData[rownames(countData), ]

  # Create dds object
  dds <- DESeqDataSetFromMatrix(countData, data$colData, ~ 1)
  sizeFactors(dds) <- sizeFactors(data$dds)
  list(taxData = taxData, countData = countData, colData = data$colData, dds = dds)
}

# diffAbundanceGenus(EXP$FUN$soil, "FUN", "soil")

EXP_genus  <- apply_to_subsets(EXP,  diffAbundanceGenus)
TIME_genus <- apply_to_subsets(TIME, diffAbundanceGenus)

e_design <- ~ experiment/block  + treatment
EXP_genus <- apply_to_subsets(EXP_genus,  deseqModel, e_design)
exp_genus_da  <- apply_to_subsets(EXP_genus, diffAbundanceOverall, "experiment")

t_design <- ~ block + treatment
time_genus_da <- apply_to_subsets(TIME_genus, diffAbundancePerTimepoint, t_design)



```

### Differential abundance at genus tables {.tabset}

#### EXP: FUN

```{r}
printDiffStats(exp_genus_da, "FUN")
exp_genus_da$FUN |> bind_rows() |> printTable()
```

#### EXP: BAC

```{r}
printDiffStats(exp_genus_da, "BAC")
exp_genus_da$BAC |> bind_rows() |> printTable()
```

#### TIME: FUN

```{r}
printDiffStats(time_genus_da, "FUN")
time_genus_da$FUN |> bind_rows() |> printTable()
```

#### TIME: BAC

```{r}
printDiffStats(time_genus_da, "BAC")
time_genus_da$BAC |> bind_rows() |> printTable()
```


### Differential abundance plots

Heatmaps of abundance of each significant ASV  in each sample

```{r}



# diffAbundanceHeatmap(EXP_genus$FUN$root, exp_genus_da$FUN$root$ASV, "experiment", FALSE, TRUE)

# agg_png(here(FIGURES_DIR, "heatmap_test.png"), width = 22, height = 15, units = "cm")
# diffAbundanceHeatmap(EXP$FUN$soil, exp_da$FUN$soil$ASV, "experiment", FALSE, FALSE) #|> draw()
# dev.off()

# agg_png(here(FIGURES_DIR, "genus_diff_BAC_root.png"), width = 20, height = 10, units = "cm")
# diffAbundanceHeatmap(EXP_genus$BAC$root, exp_genus_da$BAC$root$ASV, "experiment", FALSE, TRUE) #|> draw()
# dev.off()



# agg_png(here(FIGURES_DIR, "heatmap_test.png"))
# diffAbundanceHeatmap(TIME_genus$BAC$soil, time_genus_da$BAC$soil$ASV, "timepoint", FALSE, TRUE) #|> draw()
# dev.off()



#' @title Differential abundance heatmap
#' 
diffAbundanceHeatmapCombined <- function(data, ASVs, type, use_log1p = FALSE, genus = FALSE) {
  # Verify input lists
  stopifnot(is.list(data), all(c("soil","root") %in% names(data)))
  stopifnot(is.list(ASVs), all(c("soil","root") %in% names(ASVs)))

  # Prepare data for root and soil
  dat <- lapply(names(data), function(source) {
    # Filter dds matrix for ASVs
    mat <- counts(data[[source]]$dds, normalize = TRUE)[ASVs[[source]]$ASV, ]
    if (use_log1p) mat <- log1p(mat)
    mat[mat == 0] <- NA # Set 0 to NA for grey
    
    # Columns
    cd <- as.data.frame(data[[source]]$colData)[, c(type, "treatment", "block")]
    cd$treatment <- ifelse(cd$treatment == 0, "Control", "Waterlogged")
    cd$type <- paste(type, cd[[type]])
    cd$source  <- source

    # Sort
    ord <- with(cd, order(treatment, type, block))
    cd <- cd[ord, ]
    mat <- mat[, ord]
    colnames(mat) <- paste(cd$treatment, cd$type, cd$block, sep = "_")
    
    # Taxa
    if (!genus){
      tax <- data[[source]]$taxData[ASVs[[source]]$ASV, ]
      tax$lab <- paste0(rownames(tax), " - ", tax$rank)
      rownames(mat) <- tax$lab
    }

    list(mat = mat, cd = cd)
  })
  names(dat) <- names(data)

  mat <- rbind(dat$soil$mat, dat$root$mat)
  cd <- rbind(dat$soil$cd, dat$root$cd)

  # print(ncol(mat))
  # return(list(mat, cd))
  
  # Heatmap
  row_split <- factor(
    c(rep("soil", nrow(dat$soil$mat)), rep("root", nrow(dat$root$mat))), levels = c("soil", "root")
  )
  split <- interaction(cd[cd$source == "soil",]$type, cd[cd$source == "soil",]$treatment, sep = "\n", drop = TRUE)
  # return(split)
  ha <- HeatmapAnnotation(
    Block = anno_text(cd[cd$source == "soil",]$block, rot = 0),
    annotation_name_side = "left",
    gp = gpar(col = NA)
  )
  ht <- Heatmap(
    mat, viridis(2, option = "plasma"), "Abundance", 
    top_annotation = ha,
    column_split = split, 
    # column_title_rot = 90, #column_title = NULL,
    column_names_gp = gpar(fontsize = 10),
    row_split = row_split,
    row_names_gp = gpar(fontsize = 12),
    # row_names_max_width = unit(10, "cm"),
    cluster_rows = FALSE, cluster_columns = FALSE,
    show_column_names = FALSE,
    # show_heatmap_legend = FALSE
    heatmap_legend_param = list(
      title = ifelse(use_log1p, "Abundance (log)", "Abundance"),
      # at = c(min_pos, (min_pos+max_val)/2, max_val), # 3 ticks
      direction = "horizontal"
    ),
  )
  draw(ht, heatmap_legend_side = "bottom", padding = unit(c(2, 2, 2, 6), "mm"))
}

# Bacteria
agg_png(here(FIGURES_DIR, "genus_diff_EXP_BAC.png"), width = 20, height = 10, units = "cm")
diffAbundanceHeatmapCombined(EXP_genus$BAC, exp_genus_da$BAC, "experiment", TRUE, TRUE)
dev.off()

agg_png(here(FIGURES_DIR, "genus_diff_TIME_BAC.png"), width = 20, height = 15, units = "cm")
diffAbundanceHeatmapCombined(TIME_genus$BAC, time_genus_da$BAC, "timepoint", TRUE, TRUE)
dev.off()

# Fungi
agg_png(here(FIGURES_DIR, "genus_diff_EXP_FUN.png"), width = 20, height = 7, units = "cm")
diffAbundanceHeatmapCombined(EXP_genus$FUN, exp_genus_da$FUN, "experiment", TRUE, TRUE)
dev.off()

agg_png(here(FIGURES_DIR, "genus_diff_TIME_FUN.png"), width = 20, height = 10, units = "cm")
diffAbundanceHeatmapCombined(TIME_genus$FUN, time_genus_da$FUN, "timepoint", TRUE, TRUE)
dev.off()

```


## Functional analysis

### FUNGuilds

```{r FUNGuilds}

# Load FUNGuilds data
funguilds <- readRDS(here(OBJECT_DIR, "FUNGuilds.rds"))

mergeFunguilds <- function(data, guilds) {
  merge(data,  guilds, by.x = "ASV", by.y = "OTU")[, c(
    "Taxonomy", "guid", "mbNumber", "taxonomicLevel", "notes", "citationSource"
  ) := NULL]
}

exp_da_FUN  <- lapply(exp_da$FUN,  function(d) mergeFunguilds(d, funguilds))
time_da_FUN <- lapply(time_da$FUN, function(d) mergeFunguilds(d, funguilds))


# des_funguilds_filt <- function(data) {
#   # filt <- data[padj_X1 < 0.05 & padj_X2 < 0.05 & padj_inter > 0.05]
#   filt <- data#[!is.na(confidenceRanking) & confidenceRanking != "Possible"]
#   # filt[, c("log2FC_inter", "padj_inter", "sig_inter") := NULL]
#   filt[, correlation := ifelse(log2FC > 0, "positive", "negative")]
#   setorder(filt, log2FC)
#   split(filt, ~ source + correlation)
# }

# des_funguilds_filt(exp_da_FUN)
# des_funguilds_filt(time_da_FUN)

summariseFunguilds <- function(data) {
  data_clean <- data[!is.na(confidenceRanking) & confidenceRanking != "Possible"]

  # primary <- copy(data_clean)
  # primary[, primary := {
  #   m <- regexpr("\\|(.+?)\\|", guild)
  #   res <- regmatches(guild, m)
  #   res[which(m == -1)] <- NA
  #   res
  # }]
  # primary[, primary := gsub("\\|", "", primary)]
  # primary <- primary[!is.na(primary)]
  # primary_summary <- primary[, .(
  #   count = .N
  # ), by = primary][order(-count)]

  all <- copy(data_clean)
  all[, guild := gsub("\\|", "", guild)]
  split_list <- strsplit(all$guild, split = "-")
  indices <- rep(1:nrow(all), sapply(split_list, length))
  all_split <- all[indices]
  all_split[, guild := unlist(split_list)]
  all_summary <- all_split[, .(
    count = .N
    # proportion = .N / nrow(all_split),
  ), by = guild][order(-count)]

  # return(list(
  #   primary_guild_summary = primary_summary,
  #   all_guilds_summary = all_summary
  # ))
  all_summary
}

summariseFunguilds(exp_da_FUN$root[correlation == "positive"])

applyFunguilds <- function(data) {
  Map(function(source, dt) {
    split_data <- split(dt, f = ~ correlation)

    res <- lapply(names(split_data), function(cor) {
      guilds <- summariseFunguilds(split_data[[cor]])
      setnames(guilds, "count", cor)
      guilds
    })

    Reduce(function(x, y) merge(x, y, by = "guild", all = TRUE), res)

  }, names(data), data)
}

applyFunguilds(exp_da_FUN)#  |> printTable("Experiment")
applyFunguilds(time_da_FUN)# |> printTable("Timepoint")


```

### FAPROTAX

```{r FAPROTAX}

source(here("functional_analysis", "faprotax.R"))

fapro_dir <- here("/home/hmclean/apps/faprotax/FAPROTAX_1.2.12/")

apply_faprotaxit <- function(data, type) {
  split_data <- lapply(data, function(d) split(d, f = ~ correlation))
  
  Map(function(source, dt) {
    res <- lapply(names(dt), function(cor) {
      dt_subset <- dt[[cor]]
      fapro <- faprotaxit(
        BAC$taxData[dt_subset$ASV, ], 
        here("functional_analysis", paste("BAC", type, source, cor, "fapro.txt", sep = "_")),
        fapro_dir
      )
      setnames(fapro, "total_otus", cor)
      return(fapro)
    })
    Reduce(function(x, y) merge(x, y, by = "function_group", all = TRUE), res)
  }, names(split_data), split_data)
}

# apply_faprotaxit(exp_da$BAC, "exp")
# apply_faprotaxit(time_da$BAC, "time")


# faprotax <- list(
#   EXP = apply_faprotaxit(exp_da$BAC, "exp"),
#   TIME = apply_faprotaxit(time_da$BAC, "time")
# )

# faprotax

apply_faprotaxit(exp_da$BAC, "exp")#   |> printTable("Experiment")
apply_faprotaxit(time_da$BAC, "time")# |> printTable("Timepoint")

```